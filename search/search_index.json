{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#todo","title":"TODO","text":"<ul> <li> Deploy to GitHub Pages</li> <li> Custom page order</li> <li> DSL Dev Guide:<ul> <li> Application</li> <li> General workflow section</li> <li> Finish data structures</li> <li> Layouts</li> <li> Views</li> <li> Language syntax</li> <li> Auto-generate markdown for all definitions &amp; fill some with comments</li> <li> API</li> <li> Integrations</li> </ul> </li> <li> System maintenance docs<ul> <li> DSL Admin commands</li> <li> Deployments</li> </ul> </li> <li> Back-end<ul> <li> DB schemas</li> </ul> </li> </ul>"},{"location":"DB/CurrencyDb/","title":"Currency DB","text":""},{"location":"DB/CurrencyDb/#rate-class","title":"Rate class","text":""},{"location":"DB/CurrencyDb/#properties","title":"Properties","text":"# NAME CLASS MANDATORY READONLY NOT-NULL 0 date NUMBER true false false 1 rate DATE true false false 2 currency STR true false false <p>Records a rate by which certain currency goes under certain date. Base currency is determined inside <code>currency</code> class</p>"},{"location":"DB/CurrencyDb/#indexes","title":"Indexes","text":"# NAME PROPERTIES TYPE 0 rateIdx [currency, date] UNIQUE"},{"location":"DB/CurrencyDb/#currency-class","title":"Currency class","text":"# NAME CLASS MANDATORY READONLY NOT-NULL 0 minDate DATE true false false 1 invertBase BOOL true false false 2 minDelta NUMBER true false false 3 currency STRING true false false 4 maxDelta NUMBER true false false 5 base STRING true false false <p>Specifying the <code>base</code> currency for each <code>currency</code> field. \ud83d\udea7 TODO: invertBase always true, what is it? \ud83d\udea7 TODO: minDate, minDelta and maxDelta meanings.</p>"},{"location":"DB/CurrencyDb/#queries","title":"Queries","text":"<ul> <li><code>select from rate</code></li> </ul> # @RID @CLASS currency date rate 0 #58:0 rate BWP 2025-02-16 17:00:00 10.471 1 #58:1 rate SVC 2025-02-16 17:00:00 8.7495 2 #58:2 rate CLF 2025-02-16 17:00:00 0.024162 3 #58:3 rate NAD 2025-02-16 17:00:00 13.375 4 #58:4 rate JMD 2025-02-16 17:00:00 128.873255 5 #58:5 rate PAB 2025-02-16 17:00:00 0.999895 6 #58:6 rate WST 2025-02-16 17:00:00 2.50731 7 #58:7 rate XPD 2025-02-16 17:00:00 0.001488 8 #58:8 rate VUV 2025-02-16 17:00:00 107.379334 9 #58:9 rate AMD 2025-02-16 17:00:00 485.957501 10 #58:10 rate GBP 2025-02-16 17:00:00 0.798686 <ul> <li><code>select from currency</code></li> </ul> # @RID @CLASS currency base invertBase minDelta maxDelta minDate 0 #57:0 currency TTD USD true 3600 86400 1999-01-01 00:00:00 1 #57:1 currency BRL USD true 3600 86400 1999-01-01 00:00:00 2 #57:2 currency MGA USD true 3600 86400 1999-01-01 00:00:00 3 #57:3 currency SRD USD true 3600 86400 1999-01-01 00:00:00 4 #57:4 currency SGD USD true 3600 86400 1999-01-01 00:00:00 5 #57:5 currency GGP USD true 3600 86400 1999-01-01 00:00:00 6 #57:6 currency HTG USD true 3600 86400 1999-01-01 00:00:00 7 #57:7 currency GTQ USD true 3600 86400 1999-01-01 00:00:00 8 #57:8 currency SOS USD true 3600 86400 1999-01-01 00:00:00 9 #57:9 currency UYU USD true 3600 86400 1999-01-01 00:00:00 10 #57:10 currency TND USD true 3600 86400 1999-01-01 00:00:00"},{"location":"DB/DslDb/","title":"DSL DB","text":""},{"location":"DB/DslDb/#app-class","title":"App class","text":""},{"location":"DB/DslDb/#properties","title":"Properties","text":"# NAME LINKED-TYPE/CLASS MANDATORY READONLY NOT-NULL 0 owner STRING true false false 1 dslPackage STRING true false false 2 versions [RID] false false false 3 mng STRING true false false 4 name STRING false false false 5 description STRING false false false 6 uuid UUID true false false <p><code>dslPackage</code> represents the app name (used in dependencies, URLs and DSL class names in DB), while <code>name</code> represents human-readable app name for UI and isn't required to be set.</p> <p><code>versions</code> lists all <code>AppSource</code> records with this app</p> <p><code>owner</code> determines under which workspace the app will be listed (in system admin dashboard). <code>mng</code> determines which workspace will receive generated error messages from this app. Both <code>owner</code> and <code>mng</code> workspaces allow for app modifications within them (for all other workspaces it's in read-only mode).</p> <p><code>description</code> only for UI, \ud83d\udea7 TODO: <code>uuid</code> purpose unknown.</p>"},{"location":"DB/DslDb/#indexes","title":"Indexes","text":"# NAME PROPERTIES TYPE 0 App.dslPackage [dslPackage] UNIQUE 1 App.mng [mng] NOTUNIQUE 2 App.owner [owner] NOTUNIQUE"},{"location":"DB/DslDb/#appsource-class","title":"AppSource class","text":""},{"location":"DB/DslDb/#properties_1","title":"Properties","text":"# NAME LINKED-TYPE/CLASS MANDATORY READONLY NOT-NULL MIN MAX COLLATE DEFAULT 0 app RID true false false default 1 dslPackage STRING true false false default 2 releaseNotes STRING false false false default 3 files [OBJECT] false false false default 4 touchedOn DATE true false false default 5 uuid UUID true false false default 6 version STRING true false false default 7 dependencies [OBJECT] false false false default <p>\u26a0\ufe0f Technically not a property but <code>status</code> field is set for every document indicating which dev channel the app is on: Prod, Beta, Cancelled etc.</p> <p><code>app</code> links this version to the <code>App</code> record. <code>dslPackage</code> duplicates this apps name (<code>App.dslPackage</code>).</p> <p><code>releaseNotes</code> is for the corresponding UI field. <code>touchedOn</code> last update date. \ud83d\udea7 TODO: <code>uuid</code> purpose unknown.</p> <p><code>version</code> formatted as <code>&lt;number&gt;.&lt;number&gt;.&lt;number&gt;</code>, e.g. <code>1.0.0</code>, <code>5.41.4</code> etc.</p> <p><code>files</code> stores array of objects of structure: <code>{ name: &lt;STRING DSL &lt;&lt;FILE&gt;&gt; NAME&gt;, content: &lt;STRING DSL &lt;&lt;FILE&gt;&gt; CONTENT&gt; }</code>. Files are just visual representations in UI when you edit code in the browser (although our export / import tools also separate those into separate system files).</p> <p><code>dependencies</code> represents an array of dependencies for this app version, uses objects of structure: { dslPackage: , channelRange:  }"},{"location":"DB/DslDb/#queries","title":"Queries","text":"<ul> <li><code>select from App</code></li> </ul> # @RID @CLASS owner dslPackage versions mng uuid name description 0 #14:0 App core inventory [#12:0] core 301898890866894320827068252999597835690 1 #14:1 App 13_1 w13_1 [#12:1] 13_1 205964616463186809103591753990785401249 2 #14:2 App 13_8 w13_8 [#12:2] 13_8 224436480461500118092711859861186299895 3 #14:3 App w13_9 [#12:3] 293067100589035669072796268629798179421 4 #14:4 App 13_13 w13_13 [#12:4] 13_13 127009406275926576603515627651522476461 5 #14:5 App w13_14 [#12:5] 12595021365579212540036805690848954976 6 #14:6 App w13_16 [#12:6] 176034495396410854800586560472177104602 7 #14:7 App w13_17 [#12:7] 214862792873557138558749684635777510330 8 #14:8 App w13_21 [#12:8] 248176687705240463487547267265393795555 9 #14:9 App w13_36 [#12:9] 137821365172037241554447820236214208728 10 #14:10 App 13_40 w13_40 [#12:10] 13_40 172748718596863642921406112439751691788 11 #14:11 App w13_57 [#12:11] 137335442470786545504768165718439949855 12 #14:12 App 13_73 w13_73 [#12:12] 13_73 58395530132835021905800778058806388514 13 #14:13 App w13_75 [#12:13] 24572296635373917220293448933338634505 14 #14:14 App 13_76 w13_76 [] 13_76 239003100296143018996045752092594075809 15 #14:15 App 13_78 w13_78 [#12:14] 13_78 167012136330673499418302600632909396675 16 #14:16 App 13_79 w13_79 [#12:15] 13_79 307708543891116902439305550754166715539 17 #14:17 App 13_79 zherdev.prod [#12:16] 13_79 48343246190824829736409558743711998752 18 #14:18 App 13_78 zherdev.cafe [#12:17] 13_78 156666957942852638362158320754085611876 19 #14:19 App 13_82 w13_82 [#12:18] 13_82 2177527482051362747741086043963149354 <ul> <li><code>select from AppSource</code></li> </ul> # @RID @CLASS owner app version status dslPackage releaseNo touchedOn uuid dependencies files 0 #12:0 AppSource core #14:0 1.0.0 inventory 2017-0... 100708... [] [{name:Invoice,content:entity Invoice { ref field number: String r... 1 #12:1 AppSource 13_1 #14:1 1.0.0 Prod w13_1 2020-0... 949854... [{dslP... [] 2 #12:2 AppSource 13_8 #14:2 1.0.0 Prod w13_8 2020-0... 247353... [{dslP... [] 3 #12:3 AppSource #14:3 1.0.0 w13_9 2017-0... 314465... [] [{name:Relationships.erp,content: entity Role {field title: String ... 4 #12:4 AppSource 13_13 #14:4 1.0.0 Prod w13_13 2019-0... 181953... [{dslP... [{name:Resources.erp,content:entity Resources{ field title : String ... 5 #12:5 AppSource #14:5 1.0.0 w13_14 2017-0... 923866... [] [{name:access, menu.erp,content:role Marketing{ entity Content } },... 6 #12:6 AppSource #14:6 1.0.0 w13_16 2017-0... 112219... [] [{name:enums.erp,content:enum PlanningType{ case Goal case Challen... 7 #12:7 AppSource #14:7 1.0.0 w13_17 2017-0... 250610... [] [{name:ActionItem,content:// Something that requiers an action from th... 8 #12:8 AppSource #14:8 1.0.0 w13_21 2017-0... 130918... [] [] 9 #12:9 AppSource #14:9 1.0.0 w13_36 2017-0... 950889... [] [] 10 #12:10 AppSource 13_40 #14:10 1.0.0 Prod w13_40 2020-0... 327253... [{dslP... [{name:SavouryPotWeb,content:entity SavouryPotSupportedWebSite { fie... 11 #12:11 AppSource #14:11 1.0.0 w13_57 2017-0... 722456... [] [{name:Transaction,content:entity Transaction { field date: Date = n... 12 #12:12 AppSource 13_73 #14:12 1.0.0 w13_73 2017-0... 227558... [{dslP... [{name:NewFile.erp,content:entity Company { field code: Int field ... 13 #12:13 AppSource #14:13 1.0.0 w13_75 2017-0... 129951... [] [{name:NewFile.erp,content:entity Company { field code: Int field ... 14 #12:14 AppSource 13_78 #14:15 1.0.0 w13_78 2017-0... 602729... [{dslP... [{name:Product,content:/*entity Product { field title: String fiel... 15 #12:15 AppSource 13_79 #14:16 1.0.0 w13_79 2017-0... 605565... [{dslP... [] 16 #12:16 AppSource 13_79 #14:17 1.0.0 zherde... 2017-0... 124786... [] [] 17 #12:17 AppSource 13_78 #14:18 1.0.0 Prod zherde... 2017-0... 927067... [] [{name:Unit,content:entity Unit { width = 0.08 field shortName:... 18 #12:18 AppSource 13_82 #14:19 1.0.0 w13_82 2017-0... 134101... [] [] 19 #12:19 AppSource 13_80 #14:20 1.0.0 w13_80 2017-0... 186320... [] []"},{"location":"DB/DslDb/#export","title":"Export","text":"<pre><code>export database dsldb.json -includeSecurity=false\n</code></pre>"},{"location":"DB/DslDb/#import","title":"Import","text":"<pre><code>import database dsldb.json.gz -preserveClusterIDs=true -deleteRIDMapping=false\n</code></pre> <p>\u26a0\ufe0f By default this will overwrite the current data. To merge you must specify the <code>-merge</code> option.</p> <p>You then need to make sure that the main workspace is the manager &amp; owner of the correct Apps:</p> <pre><code>update App set mng = '57_0' where mng = '13_1'\nupdate App set owner = '57_0' where owner = '13_1'\n</code></pre>"},{"location":"DSL/Core/Any/","title":"Any","text":""},{"location":"DSL/Core/Any/#overview","title":"Overview","text":"<p>Type: interface</p> <p>Seemingely everything on our platform inherits this implicitly</p>"},{"location":"DSL/Core/Any/#functions","title":"Functions","text":""},{"location":"DSL/Core/Any/#tostring","title":"<code>toString</code>","text":"<p>Returns: <code>String?</code> Default implementation: <code>\"\"</code></p> <p>Self-explanatory, base classes (<code>Entity</code>, <code>Enum</code> etc) implement this already so unless your case is special you won't need to touch this.</p>"},{"location":"DSL/Core/Any/#views","title":"Views","text":""},{"location":"DSL/Core/Any/#form","title":"<code>form</code>","text":"<p>No default implementation.</p> <p>Seems like this view is still auto-generated outside of DSL so it doesn't need to explicity defined anyway unless required</p>"},{"location":"DSL/Core/Any/#object-native-functions","title":"Object Native Functions","text":""},{"location":"DSL/Core/Any/#interface","title":"<code>interface</code>","text":"<p>Returns: <code>Dsl</code></p> <p>Returns almost all definitions of this construct, including everything from extended constructs.</p> <p>Example:</p> <ul> <li>Query: <code>AnyRef.interface</code></li> <li>Result:     <pre><code>// interface core.AnyRef extends Any with Any\nnative fullTitle(): String\nnative get(Param(187,field,String)): T\nnative update(Param(189,field,String), Param(190,value,Any)): Ref\nnative default(Param(193,field,Ref =&gt; R)): R\nnative defaultAllField(): Void\nnative clear(Param(197,field,Ref =&gt; R)): R?\nnative updated(Param(199,field,Ref =&gt; Any)): Bool\nnative origin(Param(202,field,Ref =&gt; R)): R\nnative validationErrors(): [String]?\nnative increment(Param(205,field,Ref =&gt; Int?)): Int?\nnative silentUpdate(Param(208,field,Ref =&gt; R), Param(209,value,R)): R\nnative rollback(): Ref\nnative json(): Json\nnative xml(): Xml\nnative toMap(): [String: Any]?\nnative dslType(): DslType\n\n// interface core.Any extends \nfunc toString(): String?\nview form\n</code></pre></li> </ul> <p>Note</p> <p>As any entity can be extended further by other DSL apps, depending on which workspace you invoke this command from you might get different results.</p> <p>Danger</p> <p>As can be seen in example, this output doesn't include <code>object</code> definitions for some reaosn, not sure if this can be achieved.</p>"},{"location":"DSL/Core/Any/#hierarchy","title":"<code>hierarchy</code>","text":"<p>Returns: <code>Text</code></p> <p>Returns everything that this construct extended or extends, all super- and subtypes.</p> <p>Example:</p> <ul> <li>Query: <code>ImportTask.hierarchy</code></li> <li>Result:     <pre><code>trait core.ImportTask\n\nExtends:\ncore.Entity\n\nAll Supertypes:\ncore.Entity, core.RefEntity, core.AnyEntity, core.AnyRef, core.Any\n\nExtended by:\nflow2b.bank.BankStatementUpload, core.Import, flow2b.order.parse.OrderImport\n\nAll Subtypes:\nflow2b.bank.BankStatementUpload, core.Import, flow2b.order.parse.OrderImport\n</code></pre></li> </ul> <p>Note</p> <p>As any entity can be extended further by other DSL apps, depending on which workspace you invoke this command from you might get different results.</p>"},{"location":"DSL/Core/Any/#subobjects","title":"<code>subObjects</code>","text":"<p>Returns: <code>Set[this.object]?</code></p>"},{"location":"DSL/Core/Any/#implobjects","title":"<code>implObjects</code>","text":"<p>Returns: <code>Set[this]?</code></p>"},{"location":"DSL/Core/AnyEntity/","title":"AnyEntity","text":""},{"location":"DSL/Core/AnyEntity/#overview","title":"Overview","text":"<p>Type: trait Extends: AnyRef</p>"},{"location":"DSL/Core/AnyRef/","title":"AnyRef","text":""},{"location":"DSL/Core/AnyRef/#overview","title":"Overview","text":"<p>Type: trait Extends: AnyRef</p>"},{"location":"DSL/Core/AnyRef/#native-functions","title":"Native Functions","text":""},{"location":"DSL/Core/AnyRef/#fulltitle-string","title":"<code>fullTitle: String</code>","text":""},{"location":"DSL/Core/AnyRef/#gettfield-string-t","title":"<code>get[T](field: String): T</code>","text":""},{"location":"DSL/Core/AnyRef/#updatefield-string-value-any-this","title":"<code>update(field: String, value: Any): this</code>","text":""},{"location":"DSL/Core/AnyRef/#defaultrfield-this-r-noinferr","title":"<code>default[R](field: this =&gt; R): NoInfer[R]</code>","text":""},{"location":"DSL/Core/AnyRef/#defaultallfields-void","title":"<code>defaultAllFields(): Void</code>","text":""},{"location":"DSL/Core/AnyRef/#clearrfield-this-r-noinferr","title":"<code>clear[R](field: (this) =&gt; R): NoInfer[R?]</code>","text":""},{"location":"DSL/Core/AnyRef/#updatedfield-this-any-bool","title":"<code>updated(field: (this) =&gt; Any): Bool</code>","text":""},{"location":"DSL/Core/AnyRef/#originrfield-this-r-noinferr","title":"<code>origin[R](field: (this) =&gt; R): NoInfer[R]</code>","text":""},{"location":"DSL/Core/AnyRef/#validationerrors-string","title":"<code>validationErrors: [String]?</code>","text":""},{"location":"DSL/Core/AnyRef/#incrementfield-thisobject-int-int","title":"<code>increment(field: this.object =&gt; Int?): Int?</code>","text":""},{"location":"DSL/Core/AnyRef/#silentupdaterfield-this-r-value-noinferr-noinferr","title":"<code>silentUpdate[R](field: this =&gt; R, value: NoInfer[R]): NoInfer[R]</code>","text":""},{"location":"DSL/Core/AnyRef/#rollback-this","title":"<code>rollback: this</code>","text":""},{"location":"DSL/Core/AnyRef/#json-json","title":"<code>json: Json</code>","text":""},{"location":"DSL/Core/AnyRef/#xml-xml","title":"<code>xml: Xml</code>","text":""},{"location":"DSL/Core/AnyRef/#tomap-string-any","title":"<code>toMap: [String -&gt; Any]?</code>","text":""},{"location":"DSL/Core/AnyRef/#dsltype-dsltype","title":"<code>dslType: DslType</code>","text":""},{"location":"DSL/Core/AnyRef/#object-native-functions","title":"Object Native Functions","text":""},{"location":"DSL/Core/AnyRef/#dsltype-dsltype_1","title":"<code>dslType: DslType</code>","text":""},{"location":"DSL/Core/Entity/","title":"Entity","text":""},{"location":"DSL/Core/Entity/#overview","title":"Overview","text":"<p>Type: trait Extends: RefEntity</p>"},{"location":"DSL/Core/ImportTask/","title":"ImportTask","text":""},{"location":"DSL/Core/ImportTask/#overview","title":"Overview","text":"<p>Type: trait Extends: Entity</p>"},{"location":"DSL/Core/RefEntity/","title":"RefEntity","text":""},{"location":"DSL/Core/RefEntity/#overview","title":"Overview","text":"<p>Type: trait Extends: AnyEntity</p>"},{"location":"DSL-Dev-Guide/API/","title":"API","text":""},{"location":"DSL-Dev-Guide/API/#restful-api","title":"RESTful API","text":"<p>You can use RESTful API to get or update any entity or trait in the system.</p> <p>Endpoint URL for an entity will depend on the configuration of deployed instance, more specifically on backends <code>apiUrl</code>.</p> <p>How to get this URL when developing in DSL</p> <p>To get this URL for instance you're interested in run the following command in DSL console: <code>System.apiUrl</code>. The output will look like similar to this: <code>https://wsx.tlayen.com/api/v1</code>.</p> <p>All endpoints will begin with a structure like this: <code>$BASE_API_URL/$workspaceId/$entityFullName</code></p> <p>How to get entity's full name</p> <p>Full names are visible when you visit entity's URL in some <code>form</code>, <code>list</code> or <code>report</code>. They're just a concatenation of DSL package the entity comes from + entity name (as it appears in the code) itself. To programatically get the name you can also use the following command: <code>&lt;entity&gt;.dslType.fullName</code>.</p> Further explanations of <code>&lt;entity&gt;.dslType.fullName</code> command <p>If you executed this command from instanced entity (that you got in some previous step) the result should look as expected, however if you called it with an entity's <code>object</code> (just by name, e.g. <code>Ticket.dslType.fullName</code>) it'll end with <code>$</code>, which is just an indication that the target in question is an object. You don't need to include it in endpoint URLs.</p> <p>For example <code>GET https://wsx.tlayen.com/api/v1/73_0/flow2b.acc.finance.FinanceAccount</code> will return a list of all <code>FinanceAccount</code> entities inside workspace <code>73_0</code>.</p> <p>The response is in JSON format, with two fields:     1. <code>data</code> which contains ids of returned data.     2. <code>map</code> which contains more detailed description of all used entities in the result, so not only the requested data but also data referenced in the requested data. It will have relationship id \u2192 entity data.</p> <p>The list of finance accounts will look like:</p> <pre><code>{\n  \"data\": [\n    \"601_45\",\n    \"601_6\"\n  ],\n  \"map\": {\n    \"601_6\": {\n      \"$av\": \"List\",\n      \"id\": \"601_6\",\n      \"createdOn\": \"2017-02-18T02:51:45.730Z\",\n      \"createdBy\": \"601_2\",\n      \"touchedOn\": \"2017-02-18T02:51:45.730Z\",\n      \"legalEntity\": \"601_4\",\n      \"currency\": \"USD\",\n      \"balance\": 1400.00,\n      \"name\": \"Bank USD\"\n    },\n    \"601_4\": {\n      \"$av\": \"Ref\",\n      \"id\": \"601_4\",\n      \"title\": \"OAcc\",\n      \"pricesIncludingGst\": false,\n      \"gstStatus\": \"Registered\"\n    },\n    \"601_2\": {\n      \"$av\": \"Ref\",\n      \"id\": \"601_2\",\n      \"name\": \"Anton Zherdev\",\n      \"gstStatus\": \"NotRegistered\"\n    },\n    \"601_45\": {\n      \"$av\": \"List\",\n      \"id\": \"601_45\",\n      \"createdOn\": \"2017-02-25T21:59:41.651Z\",\n      \"createdBy\": \"601_2\",\n      \"touchedOn\": \"2017-02-25T21:59:41.651Z\",\n      \"legalEntity\": \"601_4\",\n      \"currency\": \"EUR\",\n      \"balance\": 20.00,\n      \"name\": \"Bank EUR\"\n    }\n  }\n}\n</code></pre> <p>So it contains two accounts in the result with ids <code>601_45</code> and <code>601_6</code>. The data for the accounts are in the map as well as other related entities. Such structure allows to mention every entity only once even if it's used few times and serialise recursive structures.</p> <p>A special field <code>$av</code> contains availability for the entity.</p> <p>TODO: Document availability structure</p>"},{"location":"DSL-Dev-Guide/API/#endpoints","title":"Endpoints","text":"<p>All prefixed by the aforementioned URL: <code>API_URL = $BASE_API_URL/$workspaceId}/$entityFullName</code></p> <ul> <li><code>GET $API_URL</code>: will return all items for the entity with availability <code>List</code></li> <li><code>GET $API_URL/$id</code> - will return the item id with availability <code>All</code></li> <li><code>POST $API_URL</code> - create a new item for the entity. If <code>id</code> field is presented in the body, it will work the same as <code>PATCH $API_URL/$id</code></li> <li><code>PATCH $API_URL/$id</code> - update the item. Only updated fields may be presented, other fields can be omitted</li> <li><code>DELETE $API_URL/$id</code> - delete the item</li> </ul>"},{"location":"DSL-Dev-Guide/API/#authentication","title":"Authentication","text":"<p>You can call API without authentication, but it will only have access to publicly availble data and will use the <code>Public Service</code> and its user for activities.</p> <p>If you need higher level of access you'll need to create an <code>API Service</code>, it will generate API key and secret. You can assign a necessary role to the service. Then you can use Basic Auth with the key as user name and the secret as a password.</p> <p>Warning</p> <p>You can use a real user name and password for API access but it's a bad practice as it will not be clear that it has been done using API.</p>"},{"location":"DSL-Dev-Guide/API/#call-functions-using-api","title":"Call functions using API","text":"<p>You can call some functions using API calls and it will return the result of the function in the similar way as described in RESTful API section.</p> <p>It will translate the request to the function name and parameters. It's the same endpoint as for RESTful API, in fact RESTful API is just calling the functions according to the convention.</p> <ul> <li>This will call an object function for the type: <code>$API_URL/$workspaceId/$typeFullName/$functionName</code></li> <li>This will call an instance function for the entity with id: <code>$API_URL/$workspaceId/$entityFullName/$id/$functionName</code></li> </ul> <p>Naming requirements</p> <p>There's a strict naming rule when it comes to defining such callable functions in DSL. The function must start with the lowercase REST method (<code>get</code>, <code>post</code> etc) and then PascalCase function name:</p> <ul> <li>getAccountData</li> <li>postTransaction</li> </ul> <p>When calling those functions you omit the REST method and lower its first letter:</p> <ul> <li><code>GET $API_URL/$workspace_id/$typeFullName/accountData</code></li> <li><code>POST $API_URL/$workspace_id/$typeFullName/transaction</code></li> </ul> <p>If you need to process body in the function, the request can have body as a parameter. It can be of any type and it will try to parse body in the data type.</p> <p>If you want to get headers, use <code>headers: [String -&gt; String]?</code> as a parameter. To get all parameters, use <code>params: [String -&gt; String]?</code>. To get the full http request, use <code>request: IncomingHttpRequest</code>. You can add parameters in the URL, then it will call the function with the parameters. Again it will try to parse it in a given data type.</p>"},{"location":"DSL-Dev-Guide/API/#examples","title":"Examples","text":"<ul> <li> <p><code>GET $BASE_API_URL/13_1000/foo.Foo/test</code>     This will call an <code>object func getTest</code> from <code>Foo</code> entity from <code>foo</code> package inside workspace <code>13_1000</code></p> </li> <li> <p><code>GET $BASE_API_URL/13_1000/foo.Foo/56_321/test</code>     This will call a <code>func getTest</code> from the instance with id <code>56_321</code> of entity <code>Foo</code> from package <code>foo</code> inside workspace <code>13_1000</code></p> </li> <li> <p><code>GET $BASE_API_URL/13_1000/foo.Foo</code>     This will call <code>object func get</code> from ... (same as before). If the target is an entity, that function is already implemented and it will return all items for the entity.</p> </li> <li> <p><code>GET $BASE_API_URL/13_1000/foo.Foo/foo/bar</code>     This will call <code>object func getFooBar</code> from ... (same as before).</p> <p>How the nested URL results in single function call</p> </li> <li> <p><code>GET $BASE_API_URL/13_1000/foo.Foo/test?n=10,s=test</code>     This will call <code>object func getTest(n: Int, s: String)</code> from ... (same as before).</p> </li> <li> <p><code>POST $BASE_API_URL/13_1000/foo.Foo/test</code>     This will call <code>object func postTest(body: Bar)</code> if exists or just <code>object func postTest</code> if <code>body</code> is ignored from ... (same as before).</p> </li> </ul>"},{"location":"DSL-Dev-Guide/API/#global-endpoints","title":"Global Endpoints","text":"<p>If you need to provide one URL for your app for all workspaces and then route the request to one of the workspaces, you need to implement:</p> <pre><code>inline trait WorkspaceEndpoint[D] {\n    func service: SystemService\n    func keys: [String]?\n    func router: WorkspaceRouter[D]\n    back func process(request: HttpRequest, data: D): Future[Any]\n}\n\ninterface WorkspaceRouter[D] {\n    back func parse(request: HttpRequest): D\n    back func keys(request: HttpRequest, data: D): [String]?\n}\n</code></pre> <p>Your workspace endpoint should return a key and the same key should be extracted by the workspace router from http request.</p> <p>Global endpoint URL to send requests will be: <code>$BASE_API_URL/$routerFullName</code></p>"},{"location":"DSL-Dev-Guide/API/#example","title":"Example","text":"<pre><code>entity MailService extends SystemService with WorkspaceEndpoint[MailData] {\n    func title = \u201cMail $domain\u201d\n    ref field domain: String\n    func keys: [String]? = [domain]\n    func router = MailRouter\n    func service = this\n    func process(request: IncomingHttpRequest, data: MailData): Future[Any] = {\n        Mail(data).save\n    }\n}\n\nobject MailRouter extends WorkspaceRouter[MailData] {\n    back func parse(request: IncomingHttpRequest): MailData = {\n        request.body.as[Data]!.parseJson[MailData]\n    }\n    back func keys(request: IncomingHttpRequest, data: MailData): [String]? = {\n        if (request.header(\"X-Signature\u201d) != data.subject.hmac(\"secret\u201d).sha256.hex) {\n            throw \u201cUnsigned\u201d\n        }\n        (data.to('@' .. ])!.lower\n    }\n}\n\nclass MailData {\n    field to: String\n    field subject: String\n    field text: Text\n}\n\nentity Mail {\n    field to: String\n    field subject: String\n    field text: Text\n    func title = subject\n}\n</code></pre> <p>Here we try to import mail if it's sent to the service in JSON format.</p> <p><code>MailService</code> is added in a workspace with a domain name as a setting. Domain is a key. <code>MailRouter</code> parses the JSON message in the <code>MailData</code> structure. It verifies signature to make sure that the request is coming from the expected source It extracts domain as a key. The system will match the key and route the request into the workspace with the domain. <code>MailService</code> will process the request, convert <code>MailData</code> to Mail entity and saves it. If the app is <code>foo.mail</code>, then URL for the requests will be: <code>$BASE_API_URL/foo.mail.MailRouter</code></p>"},{"location":"DSL-Dev-Guide/Applications/","title":"Applications","text":"<p>To get list of application for a workspace in the menu press <code>Admin / Apps</code>.  You will see the apps loaded by the current workspace. If you have <code>Admin</code> priveleges in the workspace you can go to the <code>System Admin</code> dashboard and see apps that are owned by this workspace. Ownership allows for app modifications and deletions, while other workspaces only allow reading. There's also a concept of manager workspace, which means that this workspace will receive all auto-generated app issues and will also have rights to modify the app.</p>"},{"location":"DSL-Dev-Guide/Applications/#workspace-app","title":"Workspace App","text":"<p>Every workspace has its own workspace app. This app will contain dependencies for other installed applications and can contain some code specific for this workspace only.</p> <p>This app cannot be deleted or used in another workspaces. It can only have one version.</p> <p>Danger</p> <p>You can still technically create mutliple versions, and I've seen it being the case in some older workspaces, but it's not advisable to do so as the results are unpredictable and support is limited.</p> <p>When you need to install an app into workspace you simply need to add dependency into the workspace app.</p>"},{"location":"DSL-Dev-Guide/Applications/#app","title":"App","text":"<p>Every app should have a unique package name. The name will be used to set dependencies and install apps.</p> <p>The app package name is a dot-separated string. It should start with your company identifier to avoid package name clash. You can use your website domain as the identifier. Then it should contain identifier for the app. For example, <code>com.telew.crm</code>.</p> <p>If the solution is complex and has more than one app, it can have longer package names. For example, <code>com.telew.inventory.stock</code> and <code>com.telew.inventory.order</code>. In this case, the base package is <code>com.telew.inventory</code>; <code>stock</code> and <code>order</code> are sub-packages.</p> <p>Note</p> <p>As far as I know there's no real difference in how you organize the apps, this hierarchy is used only for manual app imports / exports but those are not relevant for DSL devs and for common users.</p> <p>App title and description are not used anywhere currently. In future, a user will see the title and description in the app store.</p>"},{"location":"DSL-Dev-Guide/Applications/#app-dependencies","title":"App Dependencies","text":"<p>If one app is dependant on another, it can use and extend the entities and another declared types of the second app.</p> <p>You can add dependency in settings of the app version. You need to enter package name and you can also limit dependency to a particular version or version range. For example, [2.0.0, 3.0.0) means from 2.0.0 including to 3.0.0 excluding. Square bracket means including, round bracket excluding.</p>"},{"location":"DSL-Dev-Guide/Applications/#app-versioning","title":"App Versioning","text":"<p>You can have few versions of the same app. Versions have its state:</p> <ul> <li>Production: any workspace can use this version</li> <li>Development: this version will not be used by any other workspace except the workspace which owns the app or if the version is set exactly in the dependancy.</li> <li>Canceled - version is not available for any workspace.</li> </ul> <p>Notes</p> <p>TODO: No mention of Alpha / Beta / etc versions, curios if there's any functional differences between them or it's all just Development version with extra labels.</p> <p>For example, you can have 1.0.0 which is in Production, and 2.0.0 in Development. It means all workspaces which installed the app will have 1.0.0 except the workspace owning the app. However, you can force installation 2.0.0 in another workspace if you set this version in the dependency explicitly. It can be helpful for beta testing.</p> <p>There are three numbers in the version:</p> <ul> <li>Major: it should be incremented when API is changed and dependant apps can be broken.</li> <li>Minor: it should be incremented when some new functionality has been added or existing functionality has been modified.</li> <li>Patch: it should be incremented when bugs have been fixed in the app.</li> </ul>"},{"location":"DSL-Dev-Guide/Applications/#sandbox-workspaces","title":"Sandbox Workspaces","text":"<p>If you develop an application, it's recommended to create a separate sandbox workspace which will contain only testing data. This will allow to not disrupt anybody and to not damage real data during development process.</p> <p>You need to keep the app in development state until it's ready. When you change it to published state it will be immediately pushed into other workspaces dependant on this app version.</p> <p>If data conversion is required, it should be done manually through console since there is no automatic conversion currently.</p> <p>Note</p> <p>There's actually an automatic conversion mechanism in DSL, it can happen when app version number changes and must be manually coded in. TODO a guide for it.</p>"},{"location":"DSL-Dev-Guide/Bugs/","title":"Bugs","text":""},{"location":"DSL-Dev-Guide/Bugs/#column-doesnt-work-in-view-ref","title":"<code>column</code> doesn't work in <code>view ref</code>","text":"<p>For original references documentation an example of <code>impl view ref = column { ... }</code> was used, but it produces some front-end errors. It's never used in the DSL apps, instead <code>y</code> can be seen which does work correctly.</p>"},{"location":"DSL-Dev-Guide/Bugs/#row-layout-renders-in-column-when-used-in-ref-view","title":"<code>row</code> layout renders in column when used in <code>ref</code> view","text":"<p>Again usage of <code>x</code> is preferrable, it behaves as expected.</p>"},{"location":"DSL-Dev-Guide/Questions-Graveyard/","title":"Questions Graveyard","text":""},{"location":"DSL-Dev-Guide/Questions-Graveyard/#whats-the-difference-between-x-y-and-row-column-layouts","title":"What's the difference between <code>x</code> / <code>y</code> and <code>row</code> / <code>column</code> layouts?","text":""},{"location":"DSL-Dev-Guide/Questions-Graveyard/#commas-as-delimiter-for-items-in-layouts-required-or-not","title":"Commas as delimiter for items in layouts required or not?","text":""},{"location":"DSL-Dev-Guide/Data-Structure/Access/","title":"Access","text":"<p>By default, there is the <code>Admin</code> access group declared. This means that the user will have full access to everything. In a workspace, there must be at least one user with <code>Admin</code> permissions. An access group can grant access to the user. If a user does not have any access groups, he will have no permissions.</p> <pre><code>role Accountant {\n    entity Company = readWrite\n    entity Product = readOnly\n}\n</code></pre> <p>In the example, we created a new access group and granted a full access to the Company entity and a read only access to Product. You can declare a menu for the access group. If the menu is omitted, it will be autogenerated with items to the entities, traits and reports available for this role.</p> <pre><code>role Accountant {\n    entity Invoice = readWrite\n    entity Company = readWrite\n    entity Product = readOnly\n    impl view menu = y {\n        menu (\"Documents\") {\n            entity Invoice\n        }\n        menu (\"Other Entities\") {\n            entity Company\n            entity Product\n        }\n    }\n}\n</code></pre> <p>In this example the menu is created explicitly.</p> <pre><code>role Accountant {\n    entity Product {\n        read = true\n        write = type == Service\n    }\n}\n</code></pre> <p>In this example, we provided custom conditions. This means that a user will be able to read all products but save or delete only if the product's type is <code>Service</code>.</p> <pre><code>role Accountant {\n    entity Product {\n        read = type == Service\n        write = old.isEmpty || new.isEmpty || new?.type == old?.type\n    }\n}\n</code></pre> <p>You can access both old and new instances of the entity with <code>write</code> modifier. They are optional instances. If user adds a new item, old will be empty. If user deletes an item, new will be empty. If user updates an item, both of them will be filled.</p> <p>In the example, a user will be able to create and delete items and will be able to modify only if the type field is unmodified.</p> <p>You can get the current user and compare it in access groups.</p> <pre><code>entity Document {\n    field owner: User = Current\n}\n\nrole OnlyOwners {\n    entity Document {\n        read = owner.isCurrent\n        write = owner.isCurrent\n    }\n}\n</code></pre> <p>In the example, the <code>owner</code> field will be assigned by default to the current user. The access group will grant access to the items where the owner is the current user.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Collection-Fields/","title":"Collection Fields","text":"<p>Collection fields allow adding many items of similar type into an entity.</p> <pre><code>entity Foo {\n    field strings: [String]?\n    field companies: [Company]?\n}\n</code></pre> <p>In the example the <code>strings</code> field can contain many strings, the <code>companies</code> field is one to many reference field and can contain many companies. In a collection field, you can also store composite structures when you need to have few fields linked to each other.</p> <pre><code>entity Company { \n  field phones: [Phone]?\n}\n\nclass Phone { \n  field countryCode: Int \n  field number: String \n}\n</code></pre> <p>Note</p> <p>You cannot use references inside classes. If you need this, you have to use entities instead and make the reference field inline.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Compute-Field/","title":"Compute Field","text":""},{"location":"DSL-Dev-Guide/Data-Structure/Compute-Field/#definition-and-examples","title":"Definition and examples","text":"<p>Compute Field is similar to a field but it's not stored in the database and instead is computed each time on demand. To declare a compute definition, use the <code>compute</code> keyword instead of <code>field</code> and set an expression for calculation.</p> <pre><code>entity Invoice {\n    ...\n    field qty: Dec[2]\n    field total: Dec[2]\n    compute price: Dec[2] = total / qty\n    ...\n}\n</code></pre> <p>Here we declare the compute field <code>price</code>. You can simplify the declaration and omit the datatype, it will be inferred automatically:</p> <pre><code>compute price = total / qty\n</code></pre> <p>This compute field will be read only. If you want to make it editable, you have to use the <code>update</code> modifier:</p> <pre><code>compute price {\n    value = total/qty\n    update = { total = qty*price }\n}\n</code></pre> What's a <code>value</code> modifier here <p>Same as with any field you can set the default value (in our case a function to compute it) using syntax as above. In case of <code>compute</code> fields it's just named <code>value</code> instead of <code>default</code></p> <p>This means that when the price field is changed, we will update total with <code>qty * price</code>.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Entity/","title":"Entity","text":""},{"location":"DSL-Dev-Guide/Data-Structure/Entity/#definition-and-examples","title":"Definition and examples","text":"<p>Entity is something that will be stored in the database.</p> <pre><code>entity Company { \n  impl field title: String \n}\n</code></pre> <p>Here <code>Company</code> is the name of the entity, <code>title</code> is a field of type <code>String</code>.</p> <p>Info</p> <p>You can technically omit the <code>impl</code> modifier here, but it'll result in a compilation warning since all DSL entities are inhereting the title function <code>func title: String</code>.</p> Why <code>title</code> is an important definition <p>Apart from being used in the front-end for displaying the title for currently viewed entity this definition basically acts as a <code>toString</code> method for other parts of our UI (e.g. when displaying references) and even backend logic (when working with strings this definition will be used implicitly if necessary)</p> Why <code>field</code> if inhereting <code>func</code> <p>You can swap inherited properties to any other type: <code>field</code> | <code>compute field</code> | <code>function</code></p>"},{"location":"DSL-Dev-Guide/Data-Structure/Entity/#naming-conventions","title":"Naming conventions","text":"<ul> <li>use PascalCase</li> <li>use singular form of the word</li> </ul> <p>Plural form for use in front-end is auto-generated</p> <p>It's also possible to explicitly define both singular and plural forms that will be displayed for this entity:  </p> <pre><code>entity Company {\n    ...\n    singular = \"Company\"\n    plural = \"Companies\"\n    ...\n}\n</code></pre> <p>TODO</p> <p>Fields Compute Fields Functions Views</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Enums/","title":"Enums","text":"<p>If you have a fixed set of variants to choose, it is recommended to use an <code>enum</code> field.</p> <pre><code>enum TransactionType { \n    case Invoice \n    case Sale \n} \n\nentity Transaction { \n    field type: TransactionType \n}\n</code></pre> <p><code>TransactionType</code> is an <code>enum</code> class, and you can see field type is an <code>enum</code> field. TransactionType contains to cases Invoice and Sale. This field will be displayed to use as a combo box and the user will be able to select an option either <code>Invoice</code> or <code>Sale</code>. Conventionally, cases should use PascalCase.</p> <p>To provide a text which user will see you can write it as in the example or use label modifier as usual.</p> <pre><code>enum TransactionType {\n    case Invoice = \u201cCustomer Invoice\u201d\n    case Sale = \u201cWe Sale\u201d\n}\n</code></pre> <p>If you put your enum type in square brackets, user will be able to choose few options together.</p> <pre><code>enum Tag {\n    case Tag1\n    case Tag2\n    case Tag3\n}\n\nentity Company {\nf   ield tags: [Tag]\n}\n</code></pre> <p>Enums can have parameters. You can use it as a table with predifined data.</p> <pre><code>enum ClientCategory(discount: Dec[2]) {\n    case Basic(discount = 0)\n    case Premium(discount = 0.1)\n}\n\nentity Company {\n    field category: ClientCategory\n    func discount = category.discount\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Data-Structure/Field-Modifiers/","title":"Field modifiers","text":""},{"location":"DSL-Dev-Guide/Data-Structure/Field-Modifiers/#label","title":"<code>label</code>","text":"<p>This allows setting a name which will be used on UI. By default, the name of the field will be used for this. CamelCase will be translated to a user-friendly string automatically. So this modifier is required only if you want to show the user a different label than the field's name.</p> <pre><code>field name: String { label = \"Company Name\" }\n</code></pre>"},{"location":"DSL-Dev-Guide/Data-Structure/Field-Modifiers/#singular-plural","title":"<code>singular</code>, <code>plural</code>","text":"<p>For collection fields, you can define plural and singular word forms instead of a label. If it's not defined, the system will try to determine the forms automatically based on the English language rules. But it will fail to determine correctly for the words not following the rules.</p> <pre><code>field companies: [Company] {\n    singular = \"Company\"\n    plural = \"Companies\"\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Data-Structure/Field-Modifiers/#visible","title":"<code>visible</code>","text":"<p>Dynamic visibility of fields. In the example, the <code>foo</code> field will be visible only when status will be <code>Bar</code>.</p> <pre><code>field status: Status\nfield foo: String { visible = status == Bar }\n</code></pre>"},{"location":"DSL-Dev-Guide/Data-Structure/Field-Modifiers/#views","title":"<code>views</code>","text":"<p>You can set a list of views in which the field should be shown if views are autogenerated.</p> <pre><code>field foo: String { views = [list, form] }\nfield bar: String { views = [form] }\n</code></pre> <p>Here the <code>foo</code> field will be shown in both <code>list</code> and <code>form</code> views, but <code>bar</code> will be shown only in <code>form</code>.</p> <p>Tip</p> <p>Extremely useful when the inheritance structure is very complicated and where fields are added to the view automatically. In case you don't want those autogenerated fields to appear in the view (want to apply sorting first, or custom label etc) just use <code>views = []</code> and then manually add the field in the view.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Field-Modifiers/#from","title":"<code>from</code>","text":"<p>For <code>ref</code> fields you can set which entities will be shown in selector input.</p> <pre><code>ref field store: IStore {\n    from = Store.all.filter(title.contains(\"Some company\"))\n}\n</code></pre> <p>Here the <code>store</code> field will show only <code>IStore</code> entities with <code>title</code> that contains <code>\"Some company\"</code> string.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Field-Modifiers/#width","title":"<code>width</code>","text":"<p>Width in a readable column of the field which will be used in a table view by default. If it is not pointed, the system will determine default width value depending on data type.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Field/","title":"Field","text":""},{"location":"DSL-Dev-Guide/Data-Structure/Field/#definition-and-examples","title":"Definition and examples","text":"<p>Field represents some data that is stored in the database as a separate property.</p> <pre><code>entity Company {\n    ...\n    field code: Int \n    field name: String \n    ...\n}\n</code></pre> <p>Two fields are declared here for the entity <code>Company</code>: <code>code</code> and <code>name</code>. The code is an <code>Int</code> and name is a <code>String</code>.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Field/#naming-conventions","title":"Naming conventions","text":"<pre><code>- use camelCase\n- use singular form of the word\n</code></pre> <p>Same singular and plural rules apply as in entities</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Field/#default-values","title":"Default Values","text":"<p>You can set a default value for a field:</p> <pre><code>field name: String = \u201cDefault Name\u201d\n</code></pre> <p>or</p> <pre><code>field name: String {\n    default = \u201cDefault Name\u201d\n}\n</code></pre> <p>If you have a default value, you can omit the data type declaration:</p> <pre><code>field name = \u201cDefault Name\u201d\n</code></pre> <p>This field will be considered <code>String</code> automatically because \u201cDefault Name\u201d is <code>String</code>.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Fields-Availability/","title":"Fields Availability","text":""},{"location":"DSL-Dev-Guide/Data-Structure/Fields-Availability/#ref","title":"<code>ref</code>","text":"<p>When you load a form all fields of the current entity will be available. However, if you have a reference to another entity, this entity will have only a few fields loaded from the server.</p> <p>To display a reference the system will use <code>ref view</code> and <code>title</code>. So if a field is used either in the <code>ref view</code> or in <code>title</code> calculation, it should be available on the client. To make sure this is the case you should mark the field with the <code>ref</code> modifier.</p> <pre><code>entity Person {\n    ref field firstName: String?\n    ref field familyName: String\n    impl func title = \"$firstName $familyName\"\n}\n\nentity Bug {\n    impl field title: String\n    ref field status: BugStatus\n    impl view ref = row{status title}\n}\n</code></pre> <p>It's not necessary to mark the <code>title</code> field with <code>ref</code> because the system will do it implicitly.</p> <p>If you use a field in many computations it is better also to mark it as <code>ref</code> especially if it does not contain a lot of data. The computation will work anyway but the system will load full entity in a different call which will make it less performant.</p> <pre><code>entity Product {   \n    impl field title: String\n    ref field price: Dec[2]\n}\n\ninline entity InvoiceItem {\n    field product: Product\n    field quantity: Dec[2]\n    compute price = product.price\n    compute amount = quantity * price\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Data-Structure/Fields-Availability/#list","title":"<code>list</code>","text":"<p>If you load a list of items the system will not load all the fields to make it more performant. By default, it will not load collection and text fields. However, if you want to display such fields you can mark the field with <code>list</code> modifier.</p> <pre><code>entity Task {\n    impl field title: String\n    list field description: Text\n    impl object view list = Task.all &gt;&gt; nav {\n        list {\n            grid { title description }\n        }\n    }\n}\n</code></pre> <p>All fields marked with the <code>ref</code> modifier are available in lists.</p> <p>You can mark with <code>ref</code> or <code>list</code> modifier not only fields but also compute fields. It can be useful when you do not want to retrieve a collection from the server but only a result of computation:</p> <pre><code>entity Foo {\n    impl field title: String\n    list compute createdBy = activities.first?.person\n    impl object view list = Foo.all &gt;&gt; nav {\n        table { title createdBy }\n    }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Data-Structure/Fields-Availability/#availability-order","title":"Availability order","text":"<p>There are several other availability statuses for fields defined inside DSL, and each of them has order value assigned to it. Those statuses (from <code>6</code> to <code>-1</code>):</p> <p><code>Overall</code> &gt; <code>Patch(entityId)</code> &gt; <code>All</code> &gt; <code>Inline</code> &gt; <code>List</code> &gt; <code>Ref</code> &gt; <code>Nothing</code> &gt; <code>NotInit</code></p> <p>When retrieving some data from fields you need to make sure that the requested fields ordering value is lower than the ordering value of the parent field. Example:</p> <pre><code>entity PseudoPerson {\n    field name: String\n    field company: PseudoCompany\n    impl func title: String = \"Person: $name\"\n}\n\nentity PseudoCompany {\n    field name: String\n    impl func title: String = \"Company: $name\"\n}\n</code></pre> <p>In this example, when we will open <code>PseudoPerson</code> form we will see that <code>company</code> field won't show us company names properly inside selector list, and in console we will see following error:</p> <pre><code>Func calculating: Cannot update availability: com.erp.dsl.DslFieldUnavailableException: Field test.com.PseudoCompany@37146.185_180.name is unavailable: List &gt; Ref\n</code></pre> <p>To fix this we can make name field to be <code>ref</code> inside <code>PseudoCompany</code> entity like this:</p> <pre><code>entity PseudoCompany {\n    ref field name: String\n    impl func title: String = \"Company: $name\"\n}\n</code></pre> <p>Now everything should work and in selector field for <code>PseudoPerson</code> we should see proper list of companies.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Inner-Classes/","title":"Inner Classes","text":"<p>You can declare inner classes. Then you will be able to access the parent class fields.</p> <pre><code>entity Company {\n    field countryCode: Int\n    field phones: [Phone]\n\n    class Phone {\n        field countryCode: Int = this[Company].countryCode\n        field number: String\n    }\n}\n</code></pre> <p>In this example, we set the <code>countryCode</code> code default value to the same value as in the company but the user will be able to change it.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Optional/","title":"Optional","text":"<p>If a field is optional, you have to mark it explicitly, otherwise, the system will force a user to fill the field in.</p> <pre><code>entity Company { \n    impl field title: String \n    field notes: String? \n}\n</code></pre> <p>The system will force a user to fill the title field here but notes can be empty.</p> <p>Quirks</p> <p>While developing with DSL you'll probably encounter some examples of confusing behavior involving this feature:</p> <ul> <li>Some types have values that will default to <code>None</code>, i.e. missing value. E.g. for <code>String</code>s the empty string <code>\"\"</code> will be treated as <code>None</code>, and for most numeric types <code>0</code> will be treated as <code>None</code> as well, for all collections empty collection <code>[]</code> will be treated as <code>None</code> too.</li> <li>Plenty of optional values exist within existing DSL ecosystem and you'll inevitably will have to interact with them. Unfortunately sometimes the compiler goes crazy and issues errors for incompatible types because it expects optional value to be passed / thinks that the value you're working with is optional / nests several optionals resulting in <code>String???</code> data types etc. If you are sure it's not a program error you can explicitly cast to / from optional values using <code>!</code> (to remove optional type) or <code>?</code> (to assume optional type). E.g. <code>definitelyDefinedField!.someFunc(...)</code>, <code>SomeEntity.someMethod(definitelyDefinedField!)</code> or <code>couldBeOptional?.someValue</code>, <code>SomeEntity.methodWithOptionalArg(couldBeOptional?)</code> etc.</li> </ul>"},{"location":"DSL-Dev-Guide/Data-Structure/Reference/","title":"Reference","text":""},{"location":"DSL-Dev-Guide/Data-Structure/Reference/#definition-and-examples","title":"Definition and examples","text":"<p>Reference field contains a reference to another or the same entity. To do this, you can easily use the name of the entity as data type after colon:</p> <pre><code>entity Invoice {\n    field company: Company\n}\n\nentity Company { ... }\n</code></pre> <p>You can make references to any entities. Be aware that by default in UI string representation of the referenced entity will be used taken from <code>title</code> definition. Make sure that you define it properly:</p> <pre><code>entity Company {\n  ref field code: Int\n  ref field name: String\n  impl func title: String = \"$code | $name\"\n}\n</code></pre> <p>High risk of getting <code>Untitled</code> here</p> <p>You've probably noticed the use of <code>ref</code> keyword in this example. While it's not necessary for defining references between entities (or even base types as seen here) its use is required here, as without it you'll most likely see the <code>Untitled</code> being displayed instead of the intended reference. It's not clear exactly why, most likely definitions with <code>ref</code> have better availability internally and can be fetched by front-end when extracting <code>title</code>.</p> <p>By default, a selector will show only the title field. However, you can set a custom layout. For this, you should declare <code>ref</code> view.</p> <pre><code>entity Company {\n    ref field code: String\n    impl field title: String\n    impl view ref = y { title code }\n}\n</code></pre> <p>After this, all references to the Company entity will show the code field under the title field. The same layout will be also used in a selector list. But you can customise this as well as providing a refList view.</p> <pre><code>entity Company {\n    ref field code: String\n    impl field title: String\n    impl view ref = column { title code }\n    impl object view refList = Company.all &gt;&gt; table {title, code}\n}\n</code></pre> <p>Now selector will show a table with two columns instead of list of the ref layout.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Reference/#reference-modes","title":"Reference modes","text":"<p>References can work in three modes:</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Reference/#edit","title":"edit","text":"<p>This is a default mode and it means that user can select a reference.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Reference/#read","title":"read","text":"<p>This creates a read only reference field. A usual use case is backward reference like in the example:</p> <pre><code>entity Invoice {\n    field client: Company\n    ...\n}\n\nentity Company {\n  field invoices: [Invoice] read by client\n  ...\n}\n</code></pre> <p>In this case, a user will not be able to choose an existing invoice and assign it to a company but he will be able to see all invoices for the company and add a new invoice.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Reference/#inline","title":"inline","text":"<p>Inline references will look similar to an embedded field. It works well if you want to create a connection between entities with some attributes:</p> <pre><code>entity Person {\n    field roles: [OrganisationPersonRole] inline by person\n    ...\n}\n\nentity Organisation {\n    field employees: [OrganisationPersonRole] inline by organisation\n    ...\n}\n\ninline entity OrganisationPersonRole {\n    field person: Person\n    field organisation: Organisation\n    field role: String\n    field startDate: Date\n    field endDate: Date?\n}\n</code></pre> <p>Actions like deletion / restoration are propagated by default from the object contained in the inline field onto the host object. So, from the example above, if an <code>OrganisationPersonRole</code> object is deleted, its <code>Person</code> will be deleted too. Same for restoration action. To prevent this propagation, <code>touchCascade</code> property can be used:</p> <pre><code>entity Person { \n    field roles: [OrganisationPersonRole] inline by person {\n        touchCascade = false\n    }\n}\n</code></pre> <p>That way, when the object contained in the roles field is deleted, the corresponding person will not be deleted.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Reference/#bidirectional-references","title":"Bidirectional references","text":"<p>When you have a reference in one direction, sometimes you would like to easily find items which refer to this item. To achieve this you have to declare a backward reference field and using the <code>by</code> modifier link two reference fields together. Then the system will keep them in sync.</p> <pre><code>entity Invoice {\n    field company: Company\n}\n\nentity Company {\n    field invoices: [Invoice]? by company\n}\n</code></pre> <p>In the example, invoices have a company reference. In the Company entity, the invoices backward reference is declared.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Registers/","title":"Registers","text":"<p><code>Register</code> is a stored accumulated linked list. It's used to make complex computation and get result with a close constant time not dependant on amount of data in the register.</p>"},{"location":"DSL-Dev-Guide/Data-Structure/Registers/#example","title":"Example","text":"<p>For example <code>register</code> for simple stock calculations:</p> <pre><code>register StockRegister {\n    key field product: Product\n    order field date: Date\n    field qty: Qty\n    stored compute stock: Qty? = prev?.stock + qty\n}\n</code></pre> <p>Here it will accumulate stock by the key field product so you can get stock per product. <code>prev</code> is a link to the previous register item by date for the product. You can write information to the register from any entity or inline entity with <code>register</code> field:</p> <pre><code>entity Purchase {\n    field date: Date\n    field product: Product\n    field qty: Qty\n    register stock = StockRegister(product = product, date = date, qty = qty)\n}\n\nentity Sales {\n    field date: Date\n    field product: Product\n    field qty: Qty\n    register stock = StockRegister(product = product, date = date, qty = -qty)\n}\n</code></pre> <p>To get current stock for product: <code>StockRegister.current</code> To get stock for a particular date: <code>StockRegister.at(date)</code></p> <p>If we create <code>Purchase(date = Date(\"2016-01-05\u201d), product = prod1, qty = 10)</code> a register item will be created with the same data and stock will be calculated as 10 because <code>prev</code> will be empty in this case.</p> <p><code>Sales(date = Date(\"2016-01-10\u201d), product = prod1, qty = 3)</code> another register item will be created here. <code>prev</code>, in this case, will be the previous register item with 10 in stock. So result in stock will be 10 - 3 = 7. <code>StockRegister.current</code> will return the last item only with 7 in stock.</p> <p>If we create something before items already created the next items will be recalculated. For example, we forgot to create an earlier purchase but we can still do it: <code>Purchase(date = Date(\"2016-01-01\u201d), product = prod1, qty = 2)</code>. In this case, a register item will be created. <code>prev</code> will be empty and <code>stock</code> will be 2. next will be the first purchase and the register item will be recalculated giving 12 in stock. Then it will recalculate the item for sales and it gives 9 in stock.</p> <p>If you create a purchase for another product <code>Purchase(date = Date(\"2016-01-10\u201d), product = prod2, qty = 5)</code> the <code>prev</code> will be empty and stock will be 5 for <code>prod2</code>. Stock for <code>prod1</code> will stay 9. <code>StockRegister.current</code> will return two items: <code>prod1</code> - 9 and <code>prod2</code> - 5.</p>"},{"location":"DSL-Dev-Guide/Integrations/Authentication/","title":"Authentication","text":""},{"location":"DSL-Dev-Guide/Integrations/Authentication/#basic-authentication","title":"Basic Authentication","text":"<pre><code>https(\"test.com/v1/test.json\")\n    .basicAuth(userName, password)\n    .get\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Authentication/#oauth-2","title":"OAuth 2","text":"<p>You can authorize your system service with OAuth or OAuth2. For this you will need to implement <code>OAuth</code> or <code>OAuth2</code> trait and then authorization will be required when user will add the service.</p> <pre><code>entity TestIntegration extends SystemService with OAuth2 {\n    field title: String\n    func roles: [Role]? = [Admin]\n    func authAuthorizeUrl: Url = \"http://brentertainment.com/oauth2/lockdin/authorize\"\n    func authTokenExchangeUrl: Url = \"http://brentertainment.com/oauth2/lockdin/token\"\n    func authClientId = \"demoapp\"\n    func authClientSecret = \"demopass\"\n    func authScope = \" \"\n\n    view form = nav{grid{\n        title\n        serviceState\n        authorizeView\n    }}\n}\n</code></pre> <p>Then when you do HTTP requests you will need to authorize it with the service using <code>oauth</code> or <code>oauth2</code> function accordingly:</p> <pre><code>https(\"test.com/v1/test.json\")\n    .oauth2(testIntegration)\n    .get\n</code></pre> <p>Redirect URL will be:</p> <pre><code>https://ws.flow2b.com/api/oauth2/$(package)/$(integration)\n</code></pre> <p>For example:</p> <pre><code>https://ws.flow2b.com/api/oauth2/test.package/TestIntegration\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Authentication/#oauth-1","title":"OAuth 1","text":"<pre><code>entity TrademeIntegration extends SystemService with OAuth {\n    field title: String\n    func roles: [Role]? = [Admin]\n    func authTmpTokenUrl: Url = \"https://secure.tmsandbox.co.nz/Oauth/RequestToken\"\n    func authParams = [(\"scope\", \"MyTradeMeRead,MyTradeMeWrite\")].toMap\n    func authAuthorizeUrl: Url = \"https://secure.tmsandbox.co.nz/Oauth/Authorize\"\n    func authTokenExchangeUrl: Url = \"https://secure.tmsandbox.co.nz/Oauth/AccessToken\"\n    func authConsumerKey: String = \"3A53685B186A812538CF641876E8AEA7\"\n    func authConsumerSecret: String = \"B7E1A0CED8332454AE2919AE6E836354\"\n}\n\nhttps(\"api.tmsandbox.co.nz/v1/Categories.json\")\n    .oauth(trademeIntegration)\n    .get\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/DeferredJobs/","title":"Deferred Jobs","text":"<p>If you do not have a schedule but have a particular time when it should be triggered you can use deferred jobs. To disable the job you need to return <code>null</code> as <code>jobDate</code>.</p> <pre><code>entity Opportunity extends Todo with DeferredJob {\n    // ... other fields and functions ...\n    field owner: Person?\n    field nextContact: Date?\n    field service: MyService\n\n    func jobDate = contactAgain\n\n    func do = {\n        owner?.join(this)?.notify()\n        nextContact = null\n        save()\n    }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/ECommerce/","title":"E-Commerce Integration","text":""},{"location":"DSL-Dev-Guide/Integrations/ECommerce/#service","title":"Service","text":"<p>You need to do:</p> <ol> <li> <p>Add dependency to <code>flow2b.integ.ecom</code></p> </li> <li> <p>Implement trait <code>ECommerceIntegration[ID]</code> where <code>ID</code> is the data type for external identifier. This will be your service:</p> <pre><code>entity WooCommerceIntegration extends ECommerceIntegration[Int]\n</code></pre> </li> <li> <p>Add necessary settings for your e-commerce platform and implement <code>mainView</code> which will contain the settings:</p> <pre><code>ref field url: Url\nfield consumerKey: String\nfield consumerSecret: Password  \n\nview mainView = grid(labels = Top) {\n    url\n    consumerKey\n    consumerSecret\n}\n</code></pre> </li> </ol>"},{"location":"DSL-Dev-Guide/Integrations/ECommerce/#products","title":"Products","text":"<ol> <li> <p>Implement <code>updateProductJobs</code> which will upload products to e-commerce:</p> <pre><code>func updateProductJobs(change: BatchChange[ProductUpdate[ICustomerSuperProduct]]): [SystemJob]? = {\n    [UpdateProductsJob(service = this, change = change)]\n}\n</code></pre> <p>The <code>BatchChange</code> contains one or few products which were created, updated, or deleted. If your e-commerce supports batch operations, you should use it and send all updates in one or few batches. If it does not support batch operations, you can create separate jobs for every product and operation.</p> <p>In order to save external IDs for newly created products for the batch update, you can use <code>updateExtIds</code> of <code>BatchChange</code>:</p> <pre><code>change.updateExtIds(service, response.createdItems.map(id))\n</code></pre> </li> <li> <p>If the e-commerce supports categories, similarly implement <code>updateCategoryJobs</code>:</p> <pre><code>func updateCategoryJobs(change: BatchChange[ProductCategory]): [SystemJob]?\n</code></pre> <p>Categories will be separated into batches in such a way that parent categories would be created in the previous batch. Categories will be created before products.</p> </li> <li> <p>If the e-commerce supports brands, similarly implement <code>updateBrandJobs</code>:</p> <pre><code>func updateBrandJobs(change: BatchChange[Brand]): [SystemJob]?\n</code></pre> </li> <li> <p>If the e-commerce supports variations, you need to implement:</p> <pre><code>func updateAttrJobs(change: BatchChange[ProductAttr]): [SystemJob]?\nfunc updateAttrTermJobs(change: BatchChange[ProductAttrTerm]): [SystemJob]?\nfunc updateVariationJobs(change: BatchChange[ProductUpdate[ICustomerComplexProduct]]): [SystemJob]?\n</code></pre> <ul> <li><code>updateAttrJobs</code> updates attributes (e.g., color)</li> <li><code>updateAttrTermJobs</code> updates attribute terms (e.g., orange color, green color, etc.). This function will be called after <code>updateAttrJobs</code></li> <li><code>updateVariationJobs</code> updates product variations, creating combinations of products and attributes (e.g., green cup, orange cup, green plate). This function will be called after <code>updateAttrJobs</code>, <code>updateAttrTermJobs</code>, and <code>updateProductJobs</code></li> </ul> </li> </ol>"},{"location":"DSL-Dev-Guide/Integrations/ECommerce/#customer","title":"Customer","text":"<ol> <li> <p>To download customers, create a model for the customer data for e-commerce and implement trait <code>ECustomer[ID]</code>:</p> <pre><code>back class CustomerData extends ECustomer[Int] {\n    extFieldNaming = Underscore\n    field id: Int\n    field email: String\n    field firstName: String?\n    field lastName: String?\n    field username: String?\n    field billing: WooAddress?\n    field shipping: WooAddress?\n\n    func extId = id\n    func personFullName: String? = \"$firstName $lastName\".trim.or(username)\n    func emails = [email]\n    func phones = []\n    func billingAddresses = billing.toSeq\n    func deliveryAddresses = shipping.toSeq\n}\n</code></pre> </li> <li> <p>Implement <code>func downloadCustomersJobs: [SystemJob]?</code> which will return the job to download all customers. This function will be called initially or when settings are changed.</p> </li> <li> <p>In the job, parse e-commerce response into the model and call <code>make(service)</code> function which will create customers in the system:</p> <pre><code>back class DownloadCustomersJob extends SystemJob {\n    field service: WooCommerceIntegration\n\n    func do: Future[Any] = {\n        procPage(1)\n    }\n\n    func procPage(page: UInt): Future[Void] = {\n        let response &lt;- service.https(\"/customers\")\n            .param(\"page\", page)\n            .param(\"per_page\", \"10\")\n            .get\n        let customers = response.body!.parseJson[[CustomerData]?]\n        customers*.make(service)\n        if (customers.count == 10) {\n            procPage(page + 1)\n        }\n    }\n}\n</code></pre> </li> <li> <p>Register a webhook in e-commerce and create customers on the webhooks.</p> <p>If you need to register webhooks automatically to a callback URL, use:</p> <pre><code>func createWebhookJobs: [SystemJob]?\n</code></pre> <p>If you have to set a static URL, please follow #Article: Global Endpoint</p> </li> </ol>"},{"location":"DSL-Dev-Guide/Integrations/ECommerce/#order","title":"Order","text":"<ol> <li> <p>Create a model for order and implement <code>ESalesOrder[ID]</code></p> </li> <li> <p>Implement:</p> <pre><code>func downloadOrdersJobs(from: Date?): [SystemJob]?\n</code></pre> <p><code>from</code> is a date after which you need to download orders.</p> </li> <li> <p>In the job, before you import orders, call <code>service.ordersDownloaded(now)</code>. This will save the date for the next time and then download data and call <code>make(service)</code> for all orders:</p> <pre><code>back class DownloadOrdersJob extends SystemJob {\n    field service: WooCommerceIntegration\n    field from: Date?\n\n    func do: Future[Any] = {\n        service.ordersDownloaded(now)\n        procPage(1)\n    }\n\n    func procPage(page: UInt): Future[Void] = {\n        let req = service.https(\"/orders\")\n            .param(\"page\", page)\n            .param(\"per_page\", \"10\")\n        if (let from) req.param(\"after\", from.format(\"yyyy-MM-dd'T'HH:mm:ss\"))\n        let response &lt;- req.get\n        let orders = response.body!.parseJson[[OrderData]?]\n        let _ &lt;- orders*.make(service).allCompleted\n        if (orders.count == 10) {\n            procPage(page + 1)\n        }\n    }\n}\n</code></pre> </li> <li> <p>Register a webhook in e-commerce and create customers on the webhooks. Usually, you will be able to use the same infrastructure as for customers.</p> <p>If you need to register webhooks automatically to a callback URL, use:</p> <pre><code>func createWebhookJobs: [SystemJob]?\n</code></pre> <p>If you have to set a static URL, please follow #Article: Global Endpoint</p> </li> <li> <p>In order to update order state in e-commerce when the order is marked as delivered or paid in the system, implement:</p> <pre><code>func uploadOrderStateJobs(orders: [SalesOrder]): [SystemJob]?\n</code></pre> <p>You will need to update the order state in the e-commerce based on the order fields, status, deliveryState, and paymentState.</p> </li> </ol>"},{"location":"DSL-Dev-Guide/Integrations/ExternalIdentifiers/","title":"External Identifiers","text":"<p>If you need to store external identifiers, follow these steps:</p> <ol> <li> <p>Add dependency to <code>flow2b.integ</code></p> </li> <li> <p>Your <code>SystemService</code> should implement trait <code>ExtIdSource[T]</code> where <code>T</code> is the data type for the ID:</p> <pre><code>entity SomeIntegration extends SystemService with ExtIdSource[Int]\n</code></pre> <p>It can be another entity or inline entity, but usually it will be a <code>SystemService</code>.</p> </li> <li> <p>Entities or inline entities which can have external IDs should implement the <code>HasExtId</code> trait. You can extend existing entities or traits with it:</p> <pre><code>extend entity SalesOrder extends HasExtId\n</code></pre> </li> <li> <p>To save an external ID, you can use:</p> <pre><code>service.updateExtId(item, newExtId)\n</code></pre> <p>or</p> <pre><code>item.updateExtId(service, newExtId)\n</code></pre> </li> <li> <p>To get an optional external ID:</p> <pre><code>service.extId(item)\n</code></pre> <p>or</p> <pre><code>item.extId(service)\n</code></pre> </li> <li> <p>To find an item with an external ID:</p> <pre><code>service.findExtId(extIdToFind, _.as[SalesOrder])\n</code></pre> <p>This will return a <code>SalesOrder</code> with the ID. The second parameter is a function which returns an optional value. It's needed to find an item of a necessary type in the case when external IDs can be the same for different types.</p> </li> <li> <p>You can see external IDs for any item implementing <code>HasExtId</code> by calling the <code>extView</code> form. For this, in the URL just change <code>/form/</code> to <code>/extView/</code>.</p> </li> </ol>"},{"location":"DSL-Dev-Guide/Integrations/HttpRequests/","title":"HTTP Requests","text":"<p>You can make HTTP or HTTPS requests in the jobs. This will execute GET request and will return a <code>Future</code> with <code>HttpResponse</code>.</p> <pre><code>let response \u2190 https(\"www.test.com/api/something\").get\nif (response.code == 200) {\n    let foo: Foo = response.data!.parseJson[Foo]\n}\n</code></pre> <p>Response will contain code, headers and body.</p>"},{"location":"DSL-Dev-Guide/Integrations/HttpRequests/#parameters","title":"Parameters","text":"<p>You can add parameters to your request with <code>param</code> or <code>params</code> functions:</p> <pre><code>http(\"test.com/product\")\n    .param(\"id\", 10)\n    .param(\"user\", \"test\")\n    .get\n</code></pre> <p>It's the same as:</p> <pre><code>http(\"test.com/product\")\n    .params([\"id\" \u2192 10, \"user\" \u2192 \"test\"])\n    .get\n</code></pre> <p>Or a class can be used:</p> <pre><code>class Foo {\n    field id: Int\n    field user: String\n}\n\nhttp(\"test.com/product\")\n    .params(Foo(id = 10, user = \"test\"))\n    .get\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/HttpRequests/#headers","title":"Headers","text":"<p>If you need additional header use <code>header</code> or <code>headers</code> function:</p> <pre><code>http(\"test.com/product/updateTitle\")\n    .header(\"Authorization\", \"Key\")\n    .header(\"accept\", \"image/*\")\n    .post(\"Test\")\n</code></pre> <p>It's the same as:</p> <pre><code>http(\"test.com/product/updateTitle\")\n    .headers([\"Authorization\" \u2192 \"Key\", \"accept\" \u2192 \"image/*\"])\n    .post(\"Test\")\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/HttpRequests/#send-data","title":"Send Data","text":"<p>To post, put or patch some data use corresponding function with the parameter:</p> <pre><code>http(\"test.com/product/updateTitle\")\n    .post(\"Some data\")\n</code></pre> <p>You can serialize a class using #Article: Serialization:</p> <pre><code>class Foo {\n    field id: Int\n    field title: String\n}\n\nhttp(\"test.com/product/updateTitle\")\n    .post(Foo(id = 10, title = \"Test\").json)\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/HttpRequests/#post-encoded-form","title":"Post Encoded Form","text":"<p>You can post a URL encoded form with the <code>form</code> method:</p> <pre><code>class Foo {\n    field id: Int\n    field title: String\n}\n\nhttp(\"test.com/product/updateTitle\")\n    .form(Foo(id = 10, title = \"Test\"))\n    .post\n</code></pre> <p>A map can be used as well:</p> <pre><code>http(\"test.com/product/updateTitle\")\n    .form([\"id\" \u2192 \"10\", \"title\" \u2192 \"Test\"])\n    .post\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Json/","title":"JSON","text":""},{"location":"DSL-Dev-Guide/Integrations/Json/#serialization","title":"Serialization","text":"<p>Every class or entity can be serialized to JSON or deserialized from JSON. Use function <code>json</code>. For example:</p> <pre><code>class Foo {\n    field bar: String\n    field baz: Int\n}\n\nFoo(bar = \"Test\", baz = 10).json\n</code></pre> <p>It will give:</p> <pre><code>{\n    \"bar\": \"Test\",\n    \"baz\": 10\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Json/#deserialization","title":"Deserialization","text":"<p>You can deserialize <code>String</code> or <code>Data</code> with <code>parseJson</code> function:</p> <pre><code>class Foo {\n    field bar: String\n    field baz: Int\n}\n\n'{\n    \"bar\": \"Test\",\n    \"baz\": 10\n}'.parseJson[Foo] == Foo(bar = \"Test\", baz = 10)\n</code></pre> <p>If you deserialize into entity you can use key fields to make sure that the item is unique. If a key field is presented, it will search for the item with the same key. If it exists it will update other fields, if it doesn't a new item will be created.</p> <pre><code>entity Product {\n    field title: String\n    key system field externalId: Int?\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Json/#capitalization","title":"Capitalization","text":"<p>C# based product uses capitalized field names. You can use class modifier <code>jsonCapitalizeFieldNames</code>:</p> <pre><code>class Foo {\n    jsonCapitalizeFieldNames = true\n    field baz: Int\n}\n\nFoo(baz = 10).json\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"Baz\": 10\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Json/#json-name","title":"JSON Name","text":"<p>You can set a field name other than the field name with <code>extName</code> field modifier:</p> <pre><code>class Foo {\n    field baz: Int {extName = \"otherName\"}\n}\n\nFoo(baz = 10).json\n</code></pre> <p>Result:</p> <pre><code>{\n    \"otherName\": 10\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Json/#required-fields","title":"Required Fields","text":"<p>If a field is not required and empty by default it will not be included in JSON:</p> <pre><code>class Foo {\n    field baz: Int?\n}\n\nFoo(baz = 0).json\n</code></pre> <p>Result:</p> <pre><code>{}\n</code></pre> <p>However, you can use <code>extRequired</code> modifier to make it always present:</p> <pre><code>class Foo {\n    field baz: Int? {extRequired}\n}\n\nFoo(baz = 0).json\n</code></pre> <p>Result:</p> <pre><code>{\n    \"Baz\": 0\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Json/#ignored-fields","title":"Ignored Fields","text":"<p>If you do not want a field to be included in JSON, use <code>jsonIgnore</code> modifier:</p> <pre><code>class Foo {\n    field bar: String {jsonIgnore}\n    field baz: Int\n}\n\nFoo(bar = \"Test\", baz = 10).json\n</code></pre> <p>Result:</p> <pre><code>{\n    \"baz\": 10\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Json/#json-mapping","title":"JSON Mapping","text":"<p>If you want to use a different value than what's in the field when serializing or deserializing, you can use the <code>Mapper</code> interface or shorter <code>jsonMap</code> modifier:</p> <pre><code>class Foo {\n    field bar: Bar {jsonMap = BarMapper}\n}\n\nenum Bar(id: Int) {\n    case Bar1(id = 1)\n    case Bar2(id = 2)\n}\n\nobject BarMapper extends Mapper[Bar, Int] {\n    func apply(f: Bar): Int = f.id\n    func unapply(f: Int): Bar = Bar.all.find(id == f)!\n}\n\nFoo.bar(bar = Bar2).json\n</code></pre> <p>Result:</p> <pre><code>{\n    \"bar\": 2\n}\n</code></pre> <p>You can write the same thing shorter:</p> <pre><code>class Foo {\n    field bar: Bar {\n        jsonMap(apply = id, unapply = v =&gt; Bar.all.find(id == v)!)\n    }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/ScheduledJobs/","title":"Scheduled Jobs","text":"<p>You can run scheduled jobs with a cron scheduler syntax: https://en.wikipedia.org/wiki/Cron</p> <p>However in our case the first item is denoting seconds.</p> <p>It's an inlined entity and should be saved usually along with service.</p> <pre><code>entity HelloService {\n    field title: String\n    field job: HelloJob inline by service\n}\n\ninline entity HelloJob extends ScheduledJob {\n    field service: HelloService by job\n    func schedule = \"0 0 * * * ?\" //Every hour\n    func do: Future[Any] = {\n        let hello = Discussion(title = \"Hello\").save\n        Person.all.filter(login).foreach{person =&gt; \n            person.join(hello).notify()\n        }\n    }\n}\n</code></pre> <p>To disable the job you can return an empty string as a schedule.</p>"},{"location":"DSL-Dev-Guide/Integrations/SystemJobs/","title":"System Jobs","text":"<p>System jobs are used to run background tasks and make HTTP requests. A common use case is updating prices in an e-commerce system.</p>"},{"location":"DSL-Dev-Guide/Integrations/SystemJobs/#creating-a-system-job","title":"Creating a System Job","text":"<p>To create a system job, extend the <code>SystemJob</code> class:</p> <pre><code>class UpdatePricesJob extends SystemJob {\n    impl field service: MyService\n    field product: Product\n\n    impl func do: Future[Any] = {\n        https(\"example.com/api/product\").oauth2(service).post(product.json)\n    }\n}\n</code></pre> <p>In this example:</p> <ul> <li>The job updates product information via an HTTP request</li> <li>It requires a service instance for authentication</li> <li>The <code>do</code> function contains the actual job logic</li> </ul>"},{"location":"DSL-Dev-Guide/Integrations/SystemJobs/#running-a-job","title":"Running a Job","text":"<p>To execute a job, you need to enqueue it. This can be done in response to specific events, such as when a product is modified:</p> <pre><code>entity Product {\n    // ... other fields and functions ...\n\n    func onSave = {\n        UpdatePricesJob(service = myService, product = this).enqueue()\n    }\n}\n</code></pre> <p>When a product is saved:</p> <ol> <li>The job is automatically enqueued</li> <li>It runs asynchronously in the background</li> <li>The main application flow continues without waiting for the job to complete</li> </ol>"},{"location":"DSL-Dev-Guide/Integrations/SystemService/","title":"System Service","text":"<p>A system service is required when you need to: - Create integrations - Run scheduled jobs - Make HTTP requests</p> <p>To create a system service, define an entity that extends <code>SystemService</code>:</p> <pre><code>entity MyIntegration extends SystemService { \n    impl func title: String = \"My Integration\"\n    impl func roles: [Role]? = [InventoryManager] \n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/SystemService/#access-control","title":"Access Control","text":"<p>A system service operates as a user within the system and requires appropriate role assignments to access data. While the <code>Admin</code> role provides full access, it's recommended to assign specific roles with limited permissions for better security.</p>"},{"location":"DSL-Dev-Guide/Integrations/SystemService/#service-states","title":"Service States","text":"<p>A system service can be in one of several states:</p> <ul> <li>Active: The service is running normally</li> <li>Error: An error has occurred</li> <li>Disabled: Too many errors have occurred and the service has been stopped</li> <li>Inactive: The service has been manually disabled</li> </ul> <p>The service is operational only when in <code>Active</code> or <code>Error</code> state. You can disable a service by setting its state to <code>Inactive</code>.</p>"},{"location":"DSL-Dev-Guide/Integrations/SystemService/#error-handling","title":"Error Handling","text":"<p>When an error occurs:</p> <ol> <li>The service state automatically changes to <code>Error</code></li> <li>All admin users receive notifications about the error</li> </ol> <p>After fixing the error:</p> <ol> <li>Set the state back to <code>Active</code></li> <li>Keep the error notification for reference</li> <li>This allows you to track successful operations while maintaining visibility of past issues</li> </ol>"},{"location":"DSL-Dev-Guide/Integrations/Xml/","title":"XML","text":""},{"location":"DSL-Dev-Guide/Integrations/Xml/#serialization","title":"Serialization","text":"<p>Use function <code>xml</code>. For example:</p> <pre><code>class Foo {\n    field bar: String\n    field baz: Int\n}\n\nFoo(bar = \"Test\", baz = 10).xml\n</code></pre> <p>It will give:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;foo&gt;\n    &lt;bar&gt;Test&lt;/bar&gt;\n    &lt;baz&gt;10&lt;/baz&gt;\n&lt;/foo&gt;\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Xml/#attributes-vs-elements","title":"Attributes vs Elements","text":"<p>By default fields are serialized as elements.</p> <pre><code>class Foo {\n    xml = Attribute\n    field bar: String\n    field baz: Int\n}\n\nFoo(bar = \"Test\", baz = 10).xml\n</code></pre> <p>It will give:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;foo bar=\"Test\" baz=\"10\"&gt;&lt;/foo&gt;\n</code></pre> <p>You can also specify attributes for individual fields:</p> <pre><code>class Foo {\n    field bar: String\n    field baz: Int {xml = Attribute}\n}\n\nFoo(bar = \"Test\", baz = 10).xml\n</code></pre> <p>Result:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;foo baz=\"10\"&gt;\n    &lt;bar&gt;Test&lt;/bar&gt;\n&lt;/foo&gt;\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Xml/#name","title":"Name","text":"<p>You can customize element names using <code>extName</code>:</p> <pre><code>class Foo {\n    extName = \"fooTag\"\n    field bar: String {extName = \"barName\"}\n    field baz: Int\n}\n\nFoo(bar = \"Test\", baz = 10).xml\n</code></pre> <p>Result:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;fooTag&gt;\n    &lt;barName&gt;Test&lt;/barName&gt;\n    &lt;baz&gt;10&lt;/baz&gt;\n&lt;/fooTag&gt;\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Xml/#namespaces","title":"Namespaces","text":"<p>You can define XML namespaces:</p> <pre><code>class Foo {\n    xmlNamespaces = [\n        \"ns1\" -&gt; \"https://test.com/ns1\",\n        \"ns2\" -&gt; \"https://test.com/ns2\"\n    ]\n    xmlNamespace = \"ns1\"\n    field bar: String \n    field baz: Int {xmlNamespace = \"ns2\"}\n}\n\nFoo(bar = \"Test\", baz = 10).xml\n</code></pre> <p>Result:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;ns1:foo xmlns:ns1=\"https://test.com/ns1\" xmlns:ns2=\"https://test.com/ns2\"&gt;\n    &lt;ns1:bar&gt;Test&lt;/ns1:bar&gt;\n    &lt;ns2:baz&gt;10&lt;/ns2:baz&gt;\n&lt;/ns1:foo&gt;\n</code></pre> <p>If you want to use or refer to the default namespace, use an empty string.</p>"},{"location":"DSL-Dev-Guide/Integrations/Xml/#mapping","title":"Mapping","text":"<p>You can transform values during serialization:</p> <pre><code>class Foo {\n    field baz: Int {extMap(_*33)}\n}\n\nFoo(baz = 10).xml\n</code></pre> <p>Result:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;foo&gt;\n    &lt;baz&gt;330&lt;/baz&gt;\n&lt;/foo&gt;\n</code></pre>"},{"location":"DSL-Dev-Guide/Integrations/Xml/#deserialization","title":"Deserialization","text":"<p>You can deserialize XML with namespaces:</p> <pre><code>class Foo {\n    xmlNamespaces = [\n        \"ns1\" -&gt; \"https://test.com/ns1\",\n        \"ns2\" -&gt; \"https://test.com/ns2\"\n    ]\n    xmlNamespace = \"ns1\"\n    field bar: String \n    field baz: Int {xmlNamespace = \"ns2\"}\n}\n\nval xmlString = '''\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;x:foo xmlns:x=\"https://test.com/ns1\" xmlns:y=\"https://test.com/ns2\"&gt;\n    &lt;x:bar&gt;Test&lt;/x:bar&gt;\n    &lt;y:baz&gt;10&lt;/y:baz&gt;\n&lt;/x:foo&gt;\n'''\n\nxmlString.parseXml[Foo]\n</code></pre> <p>Namespace prefixes can differ - the URI is what's considered.</p>"},{"location":"DSL-Dev-Guide/Integrations/Xml/#selectors","title":"Selectors","text":"<p>If you have a complicated XML structure but need to extract a little data, you can use selectors instead of deserialization:</p> <pre><code>xmlString\n    .parseXml[XmlElement]\n    .select(\"@foo\").onlyOne?.value\n</code></pre> <p>You need to parse XML into the <code>XmlElement</code> class. Then you can use the <code>select</code> function to select a list of <code>XmlElement</code> and <code>value</code> to get the string value.</p> <pre><code>back class XmlElement {\n    native select(selector: String?): [XmlElement]?\n    native value: String?\n}\n</code></pre> <p>You can find the selector's syntax here: XPath Selector Syntax</p>"},{"location":"DSL-Dev-Guide/Language/Automation/","title":"Automation","text":"<p>In DSL you can create, modify, delete entities or show them to user. You can declare the code for example as a button action.</p> <pre><code>button(\"Create new company\") {\n    Company(title = \"New company\", code = \"New code\").save\n}\n</code></pre> <p>This code will create a new company with values set for the title and code fields and save it in the database. It will not be displayed to the user. In order to display it to the user you can use the following code.</p> <pre><code>button(\"Create new company\") {\n    Company(title = \"New company\", code = \"New code\").form.open\n}\n</code></pre> <p>It will show the form to user and will not save it into database until user's action. You can display form for existing entity by the same way.</p> <p>You can modify existing entities. In order to save changes into database you must call the <code>save</code> function. Otherwise these changes will happen only on the user's screen.</p> <pre><code>company.title = \"Modified title\"\ncompany.save\n</code></pre> <p>You can also delete an existing entity by calling the <code>delete</code> function. It will be deleted from database.</p> <pre><code>company.delete\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/CopyConstructor/","title":"Copy Constructor","text":"<p>You can create one item based on another. If the name of fields and data type of the field are the same it will copy the data. It helps to write less code:</p> <pre><code>entity Foo {\n    field a: Int\n    field b: Int\n    field c: Int\n    field d: Int\n}\n\nentity Bar {\n    field a: Int\n    field b: Int\n    field c: String\n}\n</code></pre> <p>Then if we have a <code>Foo</code> and want to make a <code>Bar</code> we can write:</p> <pre><code>Bar(foo)\n</code></pre> <p>It's similar to:</p> <pre><code>Bar(a = foo.a, b = foo.b)\n</code></pre> <p>It will not copy <code>d</code> because it does not exist in <code>Bar</code> and it will not copy <code>c</code> because data type is different but you can make it explicitly if you want:</p> <pre><code>Bar(foo, c = foo.c)\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/DataTypes/","title":"Data Types","text":""},{"location":"DSL-Dev-Guide/Language/DataTypes/#option-t","title":"Option T?","text":"<p>Optional data type allows empty value. For example:</p> <pre><code>let company: Company?\n</code></pre> <p>can contain a company or null.</p> <p>In this system, zero and empty strings are considered null and are empty values. This means that the <code>String</code> data type does not allow storing an empty string and <code>Int</code> does not allow storing zero. You need to use <code>String?</code> and <code>Int?</code>:</p> <pre><code>let zero: Int = 0 // Wrong\nlet zero: Int? = 0 // Correct\nlet empty: String = \"\" // Wrong\nlet empty: String? = \"\" // Correct\n</code></pre> <p>Optional values are implicitly converted to <code>Bool</code>. It will be <code>true</code> if the value is not empty. It means that you can use it in conditions:</p> <pre><code>let foo: String?\nif (foo) {  // if (foo.isDefined)\n} \nif (!foo) {  // if (foo.isEmpty)\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#functions","title":"Functions","text":"<ul> <li> <p><code>isEmpty: Bool</code>, <code>nonEmpty: Bool == isDefined: Bool</code>   Returns whether the option contains an item or nothing.</p> </li> <li> <p><code>toSeq: [T]?</code>   Convert to collection. It will contain one element for a defined option or no element for an empty option.</p> </li> <li> <p><code>in(collection: [T]?): Bool</code>   It checks whether the value contains in the collection. If the option is empty it returns false.</p> </li> <li> <p><code>all(predicate: T =&gt; Bool): Bool</code>   It returns true if the predicate is true for the value or the option is empty.</p> </li> <li> <p><code>exists(predicate: T =&gt; Bool): Bool</code>   It returns true if the predicate is true for the value. If the option is empty, it returns false.</p> </li> <li> <p><code>filter(predicate: T =&gt; Bool): T?</code>   Returns the same option if the predicate is true or empty if it's false.</p> </li> <li> <p><code>map[T1](f: T =&gt; T1): T1?</code>   Maps the value of the option with f or returns empty.</p> </li> <li> <p><code>flatMap[T1](f: T =&gt; T1?): T1?</code>   Maps the value of the option with f or returns empty.</p> </li> <li> <p><code>alt(default: () =&gt; T): T</code>   Returns the value or alternatively the default value if the option is empty.</p> </li> <li> <p><code>or(default: () =&gt; T?): T?</code>   Return the same option if it's defined or the option returned by the default function.</p> </li> </ul>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#dec-money-qty-int-percent-num","title":"Dec, Money, Qty, Int, Percent, Num","text":"<p>Decimal data type.</p> <ul> <li><code>Dec</code> does not allow storing zero.</li> <li><code>Dec?</code> allows storing all values including zero.</li> <li><code>UDec</code> does not allow negative values and zero.</li> <li><code>UDec?</code> allows string zero and positive types</li> </ul> <p>It can have two data type parameters: unit and precision:</p> <pre><code>let foo: Dec[ProductUnit.Kilogram, 4] = 2.1  // 2.1000 gram\nlet foo: Dec[2] = 2.1  // 2.10\nlet foo: Dec[ProductUnit.Kilogram] = 2.1  // 2.100 gram\n</code></pre> <p>The unit should be of the <code>Unit</code> data type.</p> <p>If you add a unit without a precision, it will use the default precision returned by the Unit.</p> <p>The unit can be dynamic and stored in a structure. For example:</p> <pre><code>field unit: ProductUnit\nfield foo: UDec[unit]?\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#data-type-inference","title":"Data type inference","text":"<p>If you do math operation, the compiler infers the result data type and computes whether it's always positive and optional. Rules:</p> <pre><code>(Dec|Dec?) + (Dec|Dec?|UDec|UDec?) = Dec?\nUDec? + (UDec|UDec?) = UDec?\nUDec + UDec = UDec\n(Dec|Dec?|UDec|UDec?) - (Dec|Dec?|UDec|UDec?) = Dec?\n\nDec? * (Dec|Dec?|UDec|UDec?) = Dec?\nUDec? * Dec = Dec?\nUDec? * (UDec|UDec?) = UDec?\nDec * (Dec|UDec) = Dec\nUDec * UDec = UDec\n\nDec? / (Dec|UDec) = Dec?\nDec / (Dec|UDec) = Dec\nUDec? / Dec = Dec?\nUDec? / UDec = UDec?\nUDec / Dec = Dec\nUDec / UDec = UDec\n\n-Dec? = Dec?\n-Dec = Dec\n-UDec = Dec\n-UDec? = Dec?\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#decimal-types","title":"Decimal Types","text":"<ul> <li> <p><code>Dec</code>, <code>UDec</code>   It's a generic decimal type without additional context.</p> </li> <li> <p><code>Money</code>, <code>UMoney</code>   Money is a decimal type which takes a currency as a unit.</p> <pre><code>let foo: UMoney[USD]? = 20 // $20.00\n</code></pre> </li> <li> <p><code>Qty</code>, <code>UQty</code>   It's a <code>Dec</code> alias and can take any unit as a parameter. Use it to explicitly make quantity.</p> </li> <li> <p><code>Int</code>, <code>UInt</code> <code>Int</code> does not have parameters. It's a decimal with 0 precision and no unit.</p> </li> <li> <p><code>Percent</code>, <code>UPercent</code>   This data type has the <code>Percent</code> as a unit. It has precision as a parameter. By default, the precision is 2. It means that it can store 10% but not 10.1%.</p> <pre><code>let foo: Percent? = 0.1 // 10%\nlet foo: UPercent[2] = 0.321 // 32.10%\n</code></pre> </li> <li> <p><code>Num</code>, <code>UNum</code>   It's a generic interface which can be any numeric type.</p> </li> </ul>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#bool","title":"Bool","text":"<p>Boolean datatype. Can be either <code>true</code> or <code>false</code>.</p>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#string","title":"String","text":"<p>String datatype.</p> <ul> <li> <p><code>dropPrefix(prefix: String): String</code>, <code>dropPrefixes(prefixes: [String]): String</code>   If the string starts with the prefix it drops it otherwise it returns unmodified string. The <code>dropPrefixes</code> function call <code>dropPrefix</code> in the cycle for every prefix.</p> <pre><code>\"www.google.com\".dropPrefix(\"www.\") == \"google.com\"\n\"google.com\".dropPrefix(\"www.\") == \"google.com\"\n\"https://www.google.com\".dropPrefixes([\"http://\", \"https://\", \"www.\"]) == \"google.com\"\n</code></pre> </li> <li> <p><code>dropSuffix(suffix: String): String</code>, <code>dropSuffixes(suffixes: [String]): String</code>   If the string ends with the suffix it drops it otherwise it returns unmodified string. The <code>dropSuffixes</code> function call <code>dropSuffix</code> in the cycle for every suffix.</p> <pre><code>\"www.google.com\".dropSuffix(\".com\") == \"www.google\"\n</code></pre> </li> </ul>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#text","title":"Text","text":"<p>Formatted text. Multiline string editor will be used for fields with this type. The same functions can be applied for text as for string.</p>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#date-duration","title":"Date, Duration","text":""},{"location":"DSL-Dev-Guide/Language/DataTypes/#date","title":"Date","text":"<p><code>Date</code> data type has two optional parameters which determine a lower and upper date units:</p> <ul> <li><code>Date[day, year]</code> or simply <code>Date[day]</code> will store a date only without time</li> <li><code>Date[millisecond, hour]</code> is the same as the <code>Time</code> data type</li> <li><code>Date[month, year]</code> or <code>Date[month]</code> will store date only month and year</li> <li><code>Date[millisecond, year]</code> is the same as simply <code>Date</code> will store the whole date</li> </ul> <p>Available time units are: millisecond, second, minute, hour, day, week, month, quarter and year.</p>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#timezone-and-utc","title":"Timezone and UTC","text":"<p>By default date will have timezone information if the lower unit is not higher than an hour and the upper unit is year. Otherwise, it will be always considered as UTC timezone.</p> <p>You can force <code>Date</code> not to have timezone information by using <code>UtcDate</code> instead of <code>Date</code>.</p> <p>If the code is executed on a client <code>Date</code> will have user's local timezone. If the code is executed on the server the timezone will be in the Workspace timezone. If you want to change a timezone, use the <code>timezone(zone: String): Date</code>.</p>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#duration","title":"Duration","text":"<p><code>Duration</code> data type is a number and has two parameters: time unit and precision. <code>Duration[day]</code> - duration in days, <code>Duration[day, 10]</code> - duration in day with 10 numbers after dot.</p> <p>As other number you can form duration by number underscore and unit:</p> <pre><code>let dur: Duration = 1_day\n</code></pre> <p>You can add duration to dates:</p> <pre><code>Date(2017, 12, 8) + 1_day == Date(2017, 12, 9)\n</code></pre> <p>Difference between days will return duration:</p> <pre><code>Date(2017, 12, 9) - Date(2017, 12, 8) == 1_day\n</code></pre> <p>You can make operations on durations in different units:</p> <pre><code>1_hour + 1_day == 25_hour\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/DataTypes/#map","title":"Map","text":"<p>Contains correlations between key (K) and value (V): <code>[Int: String]</code>, <code>[Company: Dec[2]]</code>.</p> <ul> <li><code>agg[I, V1 where V = [I] =&gt; V1): [K : V1]</code>   Aggregate values if they are collection. Usually it is used along with the group function.</li> </ul>"},{"location":"DSL-Dev-Guide/Language/Declarations/","title":"Declarations","text":""},{"location":"DSL-Dev-Guide/Language/Declarations/#top-level-declarations","title":"Top Level Declarations","text":"<p>On the top level of the file you can declare classes of different types:</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#entity","title":"Entity","text":"<p>An entity will be stored in the database directly and will have an id. You can makes queries on this.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#trait","title":"Trait","text":"<p>Traits contain something common for few entities. Entities can implement many traits. You can select all items of entities which implement this trait.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#class","title":"Class","text":"<p>A universal class that can contain fields, function, etc as well as entity, but it can be stored in the database only as an embedded entity field or collection field. You cannot select them directly only through its parent entity. You cannot have reference fields inside a class.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#interface","title":"Interface","text":"<p>Interface are similar to traits but it can be implemented by classes as well as entities and you cannot select data for interface.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#report","title":"Report","text":"<p>Declares report.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#enum","title":"Enum","text":"<p>Enum is a datatype which can have only few values. For example statuses.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#access","title":"Access","text":"<p>Declares an access group.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#menu","title":"Menu","text":"<p>Declares a menu.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#lower-level-declarations","title":"Lower Level Declarations","text":"<p>Inside the top level declarations you can declare:</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#field","title":"Field","text":"<p>Fields are something which will stored in database.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#func","title":"Func","text":"<p>A function. Function can have parameters and return a value.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#compute","title":"Compute","text":"<p>Compute fields are not storing in the database by default but they are shown to user as a field.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#class_1","title":"Class","text":"<p>Inner class. Instance and fields of the current class are available inside the inner class.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#view","title":"View","text":"<p>Declare a form or list view. Object related.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#case","title":"Case","text":"<p>Case for enum. Object related.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#style","title":"Style","text":"<p>Declare a style. Object related.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#entity_1","title":"Entity","text":"<p>Describe an entity access for access groups or entity reference in menu. Object related.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#query","title":"Query","text":"<p>Defines a query.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#declaration-modifiers","title":"Declaration Modifiers","text":"<p>With declarations you can use some modifiers:</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#native","title":"Native","text":"<p>This means that the function is implemented in native code and here this is only a description for the function.</p>"},{"location":"DSL-Dev-Guide/Language/Declarations/#object","title":"Object","text":"<p>Make this function related to object not to instance. This means that you cannot use other instance related declaration in this function. But you can use this function without an instance.</p> <pre><code>class Foo {\n    field instanceField: Int \n    func instanceFunc: Int = instanceField\n    object func objectFunc: Int = 22 \n    object func objectFunc2: Int = instanceField //!!!Error. You cannot use instance declarations here\n}\n\nFoo.objectFunc\nFoo.instanceFunc //!!!Error. You cannot call it without an instance\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Events/","title":"Events","text":"<p><code>Events</code> are similar to functions but it can return only <code>Void</code> or <code>Future[Any]</code>, it cannot be overridden and all code in the hierarchy will be called.</p> <p>For example, there is a system event <code>onSave</code> which is called when an entity is saved. It's declared as:</p> <pre><code>event onSave: Future[Any] = {}\n</code></pre> <p>Then you can execute a code when an entity is saved.</p> <pre><code>trait Foo {\n    event onSave = \"Foo\".log\n}\n\nentity Bar extends Foo {\n    event onSave = \"Bar\".log\n}\n</code></pre> <p>If a <code>Bar</code> is saved, the both <code>onSave</code> will be called and the log will contain the both messages. Execution order is not determined.</p> <p>Events are needed to make it possible event processing in the extension apps without breaking the main app. For example, if <code>onSave</code> would be a <code>func</code>, then the code for the previous example would look like:</p> <pre><code>trait Foo {\n    func onSave = \"Foo\".log\n}\n\nentity Bar extends Foo {\n    func onSave = {\n        let _ \u2190 super.onSave\n        \"Bar\".log\n    }\n}\n</code></pre> <p>It will work similarly. However what if trait <code>Foo</code> would not contain <code>onSave</code> function in the declaration but it would be declared in extension. It will not work because <code>super.onSave</code> will not be presented in the <code>Bar</code> in this case as there would not be <code>super.onSave</code> at all. It's just an example, there are another similar cases.</p>"},{"location":"DSL-Dev-Guide/Language/Expressions/","title":"Expressions","text":""},{"location":"DSL-Dev-Guide/Language/Expressions/#braces","title":"Braces","text":"<p>It executes a sequence of expressions and returns the value of the latest one.</p> <pre><code>func test = { \n    let a = 2\n    let b = 3 \n    a*b \n}\n</code></pre> <p>The result of the function will <code>a*b == 6</code>.</p>"},{"location":"DSL-Dev-Guide/Language/Expressions/#let","title":"Let","text":"<p>To declare an immutable variable. This variable will be visible inside braces.</p>"},{"location":"DSL-Dev-Guide/Language/Expressions/#if","title":"If","text":"<p>Conditional expression. If the condition is true it returns a positive value otherwise negative.</p> <pre><code>if (true) 1 else 2 == 1 \nif (false) 1 else 2 == 2\n</code></pre> <p>If there isn't else clause if-expression returns Option wrapped value.</p> <pre><code>func foo: Foo = ...\nfunc fooOpt: Foo? = if (cond) foo\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Expressions/#if-let","title":"If Let","text":"<p>It allows unwrapping an optional value into a variable.</p> <pre><code>func foo: Foo? = ...\nif (let x = foo) \"foo = $x\" else \"foo is empty\"\n</code></pre> <p>If you just use a simple call to a variable or a function without parameters you can avoid letting a variable name:</p> <pre><code>if (let foo = foo) ...\n</code></pre> <p>The same as:</p> <pre><code>if (let foo) ...\n</code></pre> <p>You can join several let together with a comma or space. The variables declared in the previous let are available in later:</p> <pre><code>if (let foo, let bar = foo.bar) ...\n</code></pre> <p>You can check for a condition for the variable with <code>where</code>. And you can use a condition before any variables:</p> <pre><code>if (y &lt; 20\n    let foo where foo.x &gt; 10\n    let bar = foo.bar\n) ...\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Expressions/#if-return","title":"If Return","text":"<p>It allows you to check for a condition and return a value.</p> <pre><code>if (let foo) return {\n    \"foo = $foo\"\n}\nif (let bar) return \"bar = $bar\"\n\"Foo and Bar are empty\"\n</code></pre> <p>It's the same as:</p> <pre><code>if (let foo) {\n    \"foo = $foo\"\n} else if (let bar) {\n    \"bar = $bar\"\n} else {\n    \"Foo and Bar are empty\"\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Expressions/#guard","title":"Guard","text":"<p>The guard expression allows decreasing indent and makes the flow flatter.</p> <pre><code>guard (let foo) else return {\n    \"foo is empty\"\n}\nguard (let bar = foo.bar) else return \"bar is empty\"\n\"foo = $foo, bar = $bar\"\n</code></pre> <p>It's the same but much more readable as:</p> <pre><code>if (let foo) {\n    if (let bar = foo.bar) {\n        \"foo = $foo, bar = $bar\"\n    } else {\n        \"bar is empty\"\n    }\n} else {\n    \"foo is empty\"\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Expressions/#constants","title":"Constants","text":""},{"location":"DSL-Dev-Guide/Language/Expressions/#boolean","title":"Boolean","text":"<ul> <li><code>true</code> - Boolean true value</li> <li><code>false</code> - Boolean false value</li> </ul>"},{"location":"DSL-Dev-Guide/Language/Expressions/#null","title":"Null","text":"<ul> <li><code>null</code> - Optional empty value</li> </ul>"},{"location":"DSL-Dev-Guide/Language/Expressions/#this","title":"This","text":"<p>Returns a reference to this class or you can get a reference to a parent class for inner classes:</p> <pre><code>entity Invoice { \n    class Item { \n        func invoice: Invoice = this[Invoice] \n        func item: Item = this \n    } \n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Extensions/","title":"Extensions","text":"<pre><code>entity Company {\n    field name: String\n}\n\nextend entity Company {\n    field description: String\n}\n</code></pre> <p>You can add fields into existing entity or class using the <code>extend entity</code> construction. In this example, <code>Company</code> will have the <code>description</code> field as well as <code>name</code>. It allows to add user-specific fields into existing applications.</p>"},{"location":"DSL-Dev-Guide/Language/Functions/","title":"Functions","text":"<p>Functions can take parameters. A function without parameters is almost the same as compute field but the result will not be shown to the user by default and you cannot make it editable.</p> <pre><code>entity Foo {\n  func add(x: Int, y: Int): Int = x + y\n  field bar = add(2, 3) // 2 + 3 = 5\n}\n</code></pre> <p>It's not necessary to explicitly enter a result data type. It can be inferred automatically:</p> <pre><code>func add(x: Int, y: Int) = x + y\n</code></pre> <p>Danger</p> <p>In rare cases, particularly when working with <code>Query</code> and <code>Future</code> results, implicit type conversions can lead to unexpected results. To avoid this, it's recommended to explicitly specify the return type.</p> <p>You can call function and pass parameters by the position as in the example or you can specify the name of the parameter so to make code more readable in some cases. All the examples will give the same result 5:</p> <pre><code>add(x = 2, y = 3) \nadd(x = 2, 3)\nadd(2, y = 3) \nadd(2, 3)\n</code></pre> <p>Unlike many other languages, there is no return statement. All expressions return value and this value will be used as a result of the function. If you have a sequence of instructions in your function the result of the last instruction will be the result of the function. You can use braces to achieve it:</p> <pre><code>func foo = {\n  let x = 2\n  x*x\n}\nfoo == 4\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Future/","title":"Future","text":"<p><code>Future</code> is a value which will be calculated in future but probably not ready right now. For example, when you run an http request it takes time to obtain the result.</p> <p>To process the result you need to use the <code>map</code> combinator. You can use the <code>\u2190</code> monadic sugar syntax instead which is calling <code>map</code>.</p> <pre><code>http(\"test.com\").get.map{result =&gt;\n    \u2026\n}\n</code></pre> <p>is the same as</p> <pre><code>let result \u2190 http(\"test.com\").get\n\u2026\n</code></pre> <p>Both of these constructions return <code>Future</code>.</p> <p>Warning</p> <p>Be careful in <code>if</code> expressions. If one of branches returns <code>Future</code>, other one should return <code>Future</code> too in most cases.</p>"},{"location":"DSL-Dev-Guide/Language/Inheritance/","title":"Inheritance","text":"<pre><code>trait HasCode extends Entity { \n    field code: String \n} \n\ntrait ActionItem extends Entity { \n    func name: String \n    field priority: Int \n    field status: Status \n} \n\nentity Product extends HasCode { \n    field description: Text?\n    impl func title = code\n} \n\nentity Company extends HasCode with ActionItem { \n    impl field name: String \n    impl func title = name\n}\n</code></pre> <p>Traits can be a base for entities and classes. An Entity can inherit multiple traits. All fields declared in the traits will be available in the entity. A Product will have <code>code</code> field declared in the <code>HasCode</code> trait. It declares also <code>description</code> field. So it will have these two fields.</p> <p>In this example, the <code>Company</code> entity will have: - <code>code</code> field from <code>HasCode</code> trait - <code>priority</code> and <code>status</code> from <code>ActionItem</code> - <code>name</code> field declared in the <code>Company</code></p> <p>In <code>ActionItem</code>, <code>name</code> is declared as <code>func</code>. This means that the trait itself does not create a field but requires from entity to provide either a field, compute field or a function with the same signature. This is more flexible and allows to use existing fields to calculate the value and satisfy the trait's requirements.</p> <p>It allows to avoid duplication and reuse the same structure in similar entities. It also allows defining a contract which entities should satisfy when implementing this trait.</p> <p>Classes cannot implement traits and you have to use an interface instead.</p>"},{"location":"DSL-Dev-Guide/Language/Inheritance/#impl-and-override","title":"Impl and Override","text":"<p><code>impl</code> modifier is used when the function is declared in a superclass but not implemented:</p> <pre><code>impl func foo = 20\n</code></pre> <p><code>override</code> modifier should be used if the function is implemented in a superclass:</p> <pre><code>override func foo = 20\n</code></pre> <p>A function is considered declared, not implemented and the <code>impl</code> modifier should be used if:</p> <ol> <li> <p>A function is not implemented:     <pre><code>func foo: Int\n</code></pre></p> </li> <li> <p>A function is implemented with a constant:     <pre><code>func foo: Int = 10\n</code></pre></p> </li> <li> <p>A function is implemented with a default property:     <pre><code>func foo: Int {\n    default value = bar\n}\n</code></pre></p> </li> </ol> <p>The <code>override</code> modifier should be used if a function is implemented in any other way:</p> <pre><code>func foo: Int = bar\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Json/","title":"JSON","text":""},{"location":"DSL-Dev-Guide/Language/Json/#serialization","title":"Serialization","text":"<p>Every class or entity can be serialized to JSON or deserialized from JSON. Use function <code>json</code>. For example:</p> <pre><code>class Foo {\n    field bar: String\n    field baz: Int\n}\n\nFoo(bar = \"Test\", baz = 10).json\n</code></pre> <p>It will give:</p> <pre><code>{\n    \"bar\": \"Test\",\n    \"baz\": 10\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Json/#deserialization","title":"Deserialization","text":"<p>You can deserialize <code>String</code> or <code>Data</code> with <code>parseJson</code> function:</p> <pre><code>class Foo {\n    field bar: String\n    field baz: Int\n}\n\n'{\n    \"bar\": \"Test\",\n    \"baz\": 10\n}'.parseJson[Foo] == Foo(bar = \"Test\", baz = 10)\n</code></pre> <p>If you deserialize into entity you can use key fields to make sure that the item is unique. If a key field is presented, it will search for the item with the same key. If it exists it will update other fields, if it doesn't a new item will be created.</p> <pre><code>entity Product {\n    field title: String\n    key system field externalId: Int?\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Json/#capitalization","title":"Capitalization","text":"<p>C# based product uses capitalized field names. You can use class modifier <code>jsonCapitalizeFieldNames</code>:</p> <pre><code>class Foo {\n    jsonCapitalizeFieldNames = true\n    field baz: Int\n}\n\nFoo(baz = 10).json\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"Baz\": 10\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Json/#json-name","title":"JSON Name","text":"<p>You can set a field name other than the field name with <code>extName</code> field modifier:</p> <pre><code>class Foo {\n    field baz: Int {extName = \"otherName\"}\n}\n\nFoo(baz = 10).json\n</code></pre> <p>Result:</p> <pre><code>{\n    \"otherName\": 10\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Json/#required-fields","title":"Required Fields","text":"<p>If a field is not required and empty by default it will not be included in JSON:</p> <pre><code>class Foo {\n    field baz: Int?\n}\n\nFoo(baz = 0).json\n</code></pre> <p>Result:</p> <pre><code>{}\n</code></pre> <p>However, you can use <code>extRequired</code> modifier to make it always present:</p> <pre><code>class Foo {\n    field baz: Int? {extRequired}\n}\n\nFoo(baz = 0).json\n</code></pre> <p>Result:</p> <pre><code>{\n    \"Baz\": 0\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Json/#ignored-fields","title":"Ignored Fields","text":"<p>If you do not want a field to be included in JSON, use <code>jsonIgnore</code> modifier:</p> <pre><code>class Foo {\n    field bar: String {jsonIgnore}\n    field baz: Int\n}\n\nFoo(bar = \"Test\", baz = 10).json\n</code></pre> <p>Result:</p> <pre><code>{\n    \"baz\": 10\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Json/#json-mapping","title":"JSON Mapping","text":"<p>If you want to use a different value than what's in the field when serializing or deserializing, you can use the <code>Mapper</code> interface or shorter <code>jsonMap</code> modifier:</p> <pre><code>class Foo {\n    field bar: Bar {jsonMap = BarMapper}\n}\n\nenum Bar(id: Int) {\n    case Bar1(id = 1)\n    case Bar2(id = 2)\n}\n\nobject BarMapper extends Mapper[Bar, Int] {\n    func apply(f: Bar): Int = f.id\n    func unapply(f: Int): Bar = Bar.all.find(id == f)!\n}\n\nFoo.bar(bar = Bar2).json\n</code></pre> <p>Result:</p> <pre><code>{\n    \"bar\": 2\n}\n</code></pre> <p>You can write the same thing shorter:</p> <pre><code>class Foo {\n    field bar: Bar {\n        jsonMap(apply = id, unapply = v =&gt; Bar.all.find(id == v)!)\n    }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/LocalVariables/","title":"Local Variables","text":"<p>You can declare a local immutable local variable. It can be useful to keep there a calculation result which will be used in a few places or to make the code more readable.</p> <pre><code>let x = 2 \nx*x == 4\n</code></pre> <p>You cannot assign a new value to x.</p> <p>To declare a mutable variable, use the <code>var</code> keyword:</p> <pre><code>var x = 2\nx == 2\nx = x*2\nx == 4\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/LoggingAndTracing/","title":"Logging and Tracing","text":"<p>While there is no debugger available for DSL, you can use logging and tracing functions to inspect values during execution.</p>"},{"location":"DSL-Dev-Guide/Language/LoggingAndTracing/#logging","title":"Logging","text":"<p>The <code>log</code> function allows you to print values to the console:</p> <pre><code>foo.log\n</code></pre> <p>This will print the value of <code>foo</code>. The output will be visible in: - JavaScript console (when triggered from the client) - Service activities (when executed on the server)</p> <p>You can also add a label to the log output:</p> <pre><code>foo.log(\"label\")\n</code></pre> <p>This will print: <code>label = &lt;value&gt;</code></p>"},{"location":"DSL-Dev-Guide/Language/LoggingAndTracing/#tracing","title":"Tracing","text":"<p>The <code>trace</code> function is useful for debugging expressions. It prints both the expression and its value:</p> <pre><code>(foo + 1).trace\n</code></pre> <p>This will print: <code>foo + 1 = &lt;value&gt;</code></p> <p>You can also add a label to trace output:</p> <pre><code>foo.trace(\"label\")\n</code></pre> <p>This will print: <code>label: foo = &lt;value&gt;</code></p>"},{"location":"DSL-Dev-Guide/Language/LoggingAndTracing/#chaining","title":"Chaining","text":"<p>Both <code>log</code> and <code>trace</code> functions return the original value, allowing you to chain them with other operations:</p> <pre><code>foo.trace.bar.log(\"bar\").baz\n</code></pre> <p>This makes it easy to inspect values at different points in a chain of operations.</p>"},{"location":"DSL-Dev-Guide/Language/Operators/","title":"Operators","text":""},{"location":"DSL-Dev-Guide/Language/Operators/#assignment-operator","title":"Assignment Operator","text":"<p><code>=</code> - Set operator changes value of the left operand to the value of right operand:</p> <pre><code>price = total/qty\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#dot-operator","title":"Dot Operator","text":"<p><code>.</code> - Get item property:</p> <pre><code>entity Product { \n    field supplier: Company \n    func supplierName: String = supplier.name \n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#optional-dot-operator","title":"Optional Dot Operator","text":"<p><code>?.</code> - If an item is optional and you want to get its property, you can use the optional dot operator. This will return an optional value as well:</p> <pre><code>entity Product { \n    field supplier: Company? \n    func optionalSupplierName: String? = supplier?.name \n}\n</code></pre> <p>If the right operand is also optional, this operator will join two optional values and return optional instead of optional of optional. If the right operand is also collection, this operator will return a collection instead of an optional collection.</p> <pre><code>class InvoiceItem { \n    field product: Product? \n    func productColor: Color? = product?.color \n    func productSuppliers: [Company] = product?.suppliers \n} \n\nentity Product { \n    field color: Color? \n    field suppliers: [Company] \n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#option-unwrap-operator","title":"Option Unwrap Operator","text":"<p><code>!</code> - Unwrap option value. If option is empty, computation will fail:</p> <pre><code>entity Product { \n    field supplier: Company? \n    func notOptionalSupplier: Company = supplier! \n    func notOptionalSupplierName: String = supplier!.name \n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#collection-dot-operator","title":"Collection Dot Operator","text":"<p><code>*.</code> - This operator takes a collection and returns another collection of field values:</p> <pre><code>entity Product { \n    field suppliers: [Company] \n    func supplierNames: [String] = suppliers*.name \n}\n</code></pre> <p>If the right operand is also optional, this operator will return collection of only full fields instead of collection of options. If the right operand is also collection, this operator will join the collections and return one collection instead of collection of collections.</p> <pre><code>class Invoice { \n    field products: [Product]\n    func productColors: [Color] = product*.color \n    func productSuppliers: [Company] = product*.suppliers \n} \n\nentity Product {\n    field color: Color? \n    field suppliers: [Company] \n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#substring-operators","title":"Substring Operators","text":"<p><code>[ .. ]</code>, <code>( .. )</code>, <code>[ .. )</code>, <code>( .. ]</code> - These operators allow getting substring for a string. The index of the first element is 0.</p> <pre><code>\"Test\"[1 .. 2] == \"es\"\n</code></pre> <p>It applies for a string and can have two arguments. These two arguments can be either an index or a substring to search:</p> <pre><code>\"Test string\"[\"es\" .. \"r\"] == \"est str\"\n</code></pre> <p>You can omit an expression from one of the sides, then it will start from the beginning or end of the string:</p> <pre><code>\"Test string\"[ .. \"r\"] == \"Test str\"\n</code></pre> <p>You can use round brackets instead of square in one or on both sides. Then the position will be excluded from the range:</p> <pre><code>\"Test string\"[\"es\" .. \"r\"] == \"est str\" \n\"Test string\"(\"es\" .. \"r\"] == \"t str\" \n\"Test string\"[\"es\" .. \"r\") == \"est st\" \n\"Test string\"(\"es\" .. \"r\") == \"t st\" \n\"Test\"[1 .. 2] == \"es\" \n\"Test\"(1 .. 2] == \"s\" \n\"Test\"[1 .. 2) == \"e\" \n\"Test\"(1 .. 2) == \"\"\n</code></pre> <p>You can get a substring from the last position in the string using <code>.last</code>:</p> <pre><code>\"First.second.third\"(\".\".last .. ] == \"Third\"\n</code></pre> <p>You can make an optional substring when it will return the string from the start or till the end if the value is not found. You need to use <code>?</code> for this:</p> <pre><code>\"first/second\"(\"/\" .. \".\") == \"\" \n\"first/second\"(\"/\" .. \".\"?) == \"second\"\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#math-operators","title":"Math Operators","text":""},{"location":"DSL-Dev-Guide/Language/Operators/#addition","title":"Addition (<code>+</code>)","text":"<p>Add two numeric values or concatenate strings:</p> <pre><code>1 + 2 == 3\n\"1\" + \"2\" == \"12\"\n\"1\" + 2 == \"12\"\n</code></pre> <p>Additionally, you can join two collections together or add an element to the collection:</p> <pre><code>[1, 2] + [2, 3] == [1, 2, 2, 3]\n[1, 2] + 3 == [1, 2, 3]\n1 + [2, 3] == [1, 2, 3]\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#subtraction-","title":"Subtraction (<code>-</code>)","text":"<pre><code>1 - 2 == -1\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#multiplication","title":"Multiplication (<code>*</code>)","text":"<pre><code>2 * 3 == 6\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#division","title":"Division (<code>/</code>)","text":"<pre><code>6 / 2 == 3\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#power-pow","title":"Power (<code>pow</code>)","text":"<p>Exponent. It returns with the same precision as the first argument:</p> <pre><code>2.pow(3) == 8\n2.00.pow(-1) == 0.5\n2.as[Number[4]].pow(2.5) == 5.6569\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#comparison-operators","title":"Comparison Operators","text":""},{"location":"DSL-Dev-Guide/Language/Operators/#equal","title":"Equal (<code>==</code>)","text":"<p>Equal operator returns true if two values are equal:</p> <pre><code>1 == 1 == true\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#not-equal","title":"Not Equal (<code>!=</code>)","text":"<p>Not equal operator returns true if two values are not equal:</p> <pre><code>1 != 1 == false\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#in-in","title":"In (<code>in</code>)","text":"<p>Checks whether the value contains in a collection:</p> <pre><code>3 in [1, 3, 6]\n</code></pre> <p>Optional values can be used:</p> <pre><code>let role: Role? = Salesperson\nrole in [Salesperson, BusAdmin]\n</code></pre> <p>The right side can be any expression, not only a collection constant:</p> <pre><code>let options = [1, 3, 6]\nx in options\n</code></pre> <p>Not in will be:</p> <pre><code>2 !in [1, 3, 6]\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#greater","title":"Greater (<code>&gt;</code>)","text":"<pre><code>2 &gt; 1\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#greater-or-equal","title":"Greater or Equal (<code>&gt;=</code>)","text":"<pre><code>2 &gt;= 1\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#less","title":"Less (<code>&lt;</code>)","text":"<pre><code>1 &lt; 2\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#less-or-equal","title":"Less or Equal (<code>&lt;=</code>)","text":"<pre><code>1 &lt;= 2\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#conditional-comparison-operators","title":"Conditional Comparison Operators","text":"<p><code>==?</code>, <code>?==</code>, <code>!=?</code>, <code>?!=</code>, <code>&gt;?</code>, <code>?&gt;</code>, <code>&gt;=?</code>, <code>?&gt;=</code>, <code>&lt;?</code>, <code>?&lt;</code>, <code>&lt;=?</code>, <code>?&lt;=</code></p> <p>The operators do the same as conditional operators but they will accept one optional side. If it's empty, it will return true. Otherwise, it will return the result of the conditional operation.</p> <p>It's very convenient for conditional filtering in reports:</p> <pre><code>foo &gt;? lowerFoo\n</code></pre> <p>Instead of:</p> <pre><code>!lowerFoo || foo &gt; lowerFoo!\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#logical-operators","title":"Logical Operators","text":""},{"location":"DSL-Dev-Guide/Language/Operators/#not","title":"Not (<code>!</code>)","text":"<p>The inverse unary logical operator returns true if the operand is false and vice versa:</p> <pre><code>!true == false\n!false == true\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#and","title":"And (<code>&amp;&amp;</code>)","text":"<p>Logical and operator returns true only if both operands are true otherwise false:</p> <pre><code>true &amp;&amp; true == true \ntrue &amp;&amp; false == false\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#or","title":"Or (<code>||</code>)","text":"<p>Logical or operator returns false only if both operands are false otherwise true:</p> <pre><code>false || false == false \ntrue || false == true\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Operators/#operator-order","title":"Operator Order","text":"<p>Binary operators have a natural order and you can use brackets to control the order:</p> <pre><code>1 + 2*3 == 1 + (2*3) != (1 + 2)*3\n</code></pre> <p>If operators are in the same group the order will be from left to right.</p> <p>Order of operations (from highest to lowest precedence): 1. <code>=</code> 2. <code>||</code> 3. <code>&amp;&amp;</code> 4. <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code> 5. <code>+</code>, <code>-</code> 6. <code>*</code>, <code>/</code></p>"},{"location":"DSL-Dev-Guide/Language/Queries/","title":"Queries","text":"<p>Every function's description will use the sample data to show its result.</p> <pre><code>entity Invoice {\n    field number: String\n    field total: Dec[2]\n    field items: [InvoiceItem] inline by invoice\n}\n\nentity InvoiceItem {\n    field invoice: Invoice\n    field product: String\n    field amount: Dec[2]\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Queries/#sample-data","title":"Sample Data","text":""},{"location":"DSL-Dev-Guide/Language/Queries/#invoice","title":"Invoice:","text":"<pre><code>number    total\n1           100\n2           200\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Queries/#invoiceitem","title":"InvoiceItem:","text":"<pre><code>invoice    product    amount\n1          p1             70\n1          p2             30\n2          p2            200\n</code></pre>"},{"location":"DSL-Dev-Guide/Language/Queries/#query-functions","title":"Query Functions","text":""},{"location":"DSL-Dev-Guide/Language/Queries/#all","title":"<code>all</code>","text":"<p>To select all items for entity. Usually a query will be started from all items for an entity.</p> <pre><code>Invoice.all\n</code></pre> <p>Result: <pre><code>number    total\n1    100\n2    200\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#filter","title":"<code>filter</code>","text":"<p>Filter invoices with total more than 100.</p> <pre><code>Invoice.all.filter(total &gt; 100)\n</code></pre> <p>Result: <pre><code>number    total\n2           200\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#find","title":"<code>find</code>","text":"<p>Find return the first item satisfied the condition if it exists.</p> <pre><code>Invoice.all.find(total &gt; 100)\n</code></pre> <p>Result: <pre><code>number = 2\ntotal = 200\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#exists","title":"<code>exists</code>","text":"<p>It returns true if there is an item which satisfies the condition.</p> <pre><code>Invoice.all.exists(total &gt; 100)\n</code></pre> <p>Result: <pre><code>true\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#map","title":"<code>map</code>","text":"<pre><code>Invoice.all.map(total, foo = total2, bar = total3)\n</code></pre> <p>Result: <pre><code>total    foo    bar\n100    200    300\n200    400    600\n</code></pre></p> <p>It takes every item in the query and returns a new according to the expressions.</p>"},{"location":"DSL-Dev-Guide/Language/Queries/#flatmap","title":"<code>flatMap</code>","text":"<pre><code>query = Invoice.all.flatMap(items)\n</code></pre> <p>Result: <pre><code>invoice    product    amount\n1    p1    70\n1    p2    30\n2    p2    200\n</code></pre></p> <p>It is working the same way as map, but instead of returning collection of collections, it joins the collections together.</p> <pre><code>Invoice.all.map(items)\n</code></pre> <p>Result: <pre><code>items\ninvoice    product    amount\n1          p1             70\n1          p2             30\ninvoice    product    amount\n2          p2            200\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#_1","title":"<code>*.</code>","text":"<p>This is a shortcut syntax for map or flatMap if you return only one field.</p> <pre><code>Invoice.all*.total \n</code></pre> <p>Result: <pre><code>total\n100\n200\n</code></pre></p> <p>Query:</p> <pre><code>Invoice.all*.items\n</code></pre> <p>Result: <pre><code>invoice    product    amount\n1    p1    70\n1    p2    30\n2    p2    200\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#groupby","title":"<code>groupBy</code>","text":"<p>It groups items with provided key. Usually it is used along with the agg.</p> <pre><code>InvoiceItem.all.groupBy(product)\n</code></pre> <p>Result: <pre><code>product \np1 \n    invoice    product    amount\n    1          p1             70\np2 \n    invoice    product    amount\n    1          p2             30\n    2          p2            200\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#agg","title":"<code>agg</code>","text":"<p>It aggregated previously grouped results.</p> <pre><code>InvoiceItem.all.groupBy(product).agg(amount.sum)\n</code></pre> <p>Result: <pre><code>product    amount\np1             70\np2            230\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#accum","title":"<code>accum</code>","text":"<p>Cumulative sum.</p> <pre><code>Invoice.all.accum(acc = total.sum)\n</code></pre> <p>Result: <pre><code>number    total    acc\n1           100    100\n2           200    300\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Language/Queries/#sortby","title":"<code>sortBy</code>","text":"<p>Sort items in the query.</p> <pre><code>InvoiceItem.all.sortBy(product.title, amount.desc)\n</code></pre> <p>In the example, we sort by product title. If the title is the same then we by amount in a reverse order (descending).</p> <p>Result: <pre><code>invoice    product    amount\n1          p1             70\n2          p2            200\n1          p2             30\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Views/DeclareMenu/","title":"Declare Menu","text":"<p>You can declare a menu in a layout. The menu items can open list views for an entity, report or trait.</p> <pre><code>role SalesPersonRole {\n    menu Main {\n        entity Invoice \n        entity Company\n        trait ActionItem\n        report InvoiceReport\n    }\n}\n</code></pre> <p>This will create a menu section with name <code>Main</code> and items for <code>Invoice</code>, <code>Company</code>, <code>ActionItem</code> trait, and <code>InvoiceReport</code>.</p> <p>You can also control what list view you want to open and customize the menu item label:</p> <pre><code>role SalesPersonRole {\n    menu MainMenu {\n        entity Invoice {\n            label = \"Invoices\"\n            list = myList\n        }\n        entity Company \n    }\n}\n\nentity Invoice {\n    object view myList = Invoice.all &gt;&gt; table{code}\n}\n</code></pre> <p>Note</p> <p>The <code>label</code> parameter allows you to customize how the menu item appears to users, while the <code>list</code> parameter lets you specify which view to use when the menu item is clicked.</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/","title":"Layouts","text":""},{"location":"DSL-Dev-Guide/Views/Layouts/#navigation","title":"Navigation","text":"<p><code>nav</code> layout creates:</p> <ul> <li>Navigation bar</li> <li>Filters panel for a list view</li> <li>Activities panel with comments for a form</li> </ul> <pre><code>entity Company {\n    field title: String\n    view form = nav { \n        grid {\n            title\n        }\n    }\n}\n</code></pre> <p>Without <code>nav</code> you will get only a grid without navigation bar and comments</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#table","title":"Table","text":"<p><code>table</code> shows field labels in header and then rows for every item. Usually it is only used to show many items as a list view or to show collection fields.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    object view list = Company.all &gt;&gt; nav {\n        table { code, name }\n    }\n}\n</code></pre> <p>You can use it inside a form as well:</p> <pre><code>entity Invoice {\n    field number\n    field items: [InvoiceItem] inline\n    view form = nav {\n        column {\n            grid { number }\n            items &gt;&gt; table { product, qty }\n        }\n    }\n}\n\nentity InvoiceItem {\n    field product: Product\n    field qty: Dec[2]\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Layouts/#list","title":"List","text":"<p><code>list</code> layout allows to replicate any other layouts and show collection field.</p> <pre><code>entity Invoice {\n    field number: String\n    field data: Date\n    field items: [InvoiceItem] inline\n    view form = column {\n        grid {\n            number\n            date\n            items &gt;&gt; list {\n                grid(labelsAlignment = Top) { product, qty }\n            }\n        }\n    }\n}\n\nentity InvoiceItem {\n    field product: Product\n    field qty: Dec[2]\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Layouts/#grid","title":"Grid","text":"<p><code>grid</code> layout shows fields with labels. First of all, it determines the most convenient for reading text column width depending on the maximum available width for the layout and desirable amount of text columns for the grid. You can set amount of text columns using the width modifier. By default it's 1.0 but it can make sense to make it higher for multicolumn forms.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    field description: String\n    impl view form = grid {\n        code\n        name\n        description\n    }\n}\n</code></pre> <p>The grid layout can decrease or increase the font size ensuring the best user experience for his screen size. If screen size is too small it can break multicolumn form and convert it into one column.</p> <p>To create a multicolumn form you have to use the row sublayout. In this case labels will be on the top because it's recommended way from user experience perspective.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    field description: String\n    impl view form = grid {\n        row { code, name }\n        description\n    }\n}\n</code></pre> <p>Row will show few fields on the same row. By default all fields will have the same width. You can modify it using the width modifier. It measures width in text columns as well as grid layout. The sum of widths of fields in a row should not be higher than the grid's width.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    field description: String\n    impl view form = grid {\n        row { code &gt;&gt; field(width = 0.3), name &gt;&gt; field(width = 0.7) }\n        description\n    }\n}\n</code></pre> <p>If you need to create a free space in the form, you can use the <code>space</code> sublayout.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    field description: String\n    impl view form = grid {\n        row {\n            space(width = 0.4),\n            code &gt;&gt; field(width = 0.3),\n            name &gt;&gt; field(width = 0.3)\n        }\n        description\n    }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Layouts/#columns-rows","title":"Columns &amp; Rows","text":"<p>Self-explanatory, can be referenced in code as <code>column</code> / <code>row</code> or <code>y</code> / <code>x</code> respectivelly.</p> <p>There are some front-end bugs involving <code>column</code> / <code>row</code> layouts specifically, prefer <code>y</code> / <code>x</code></p> <pre><code>entity Company {\n    field status: Status\n    field code: Int\n    field name: String\n    field description: String\n    impl view form = grid {\n        x { status code }\n        y { name description }\n    }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Layouts/#fields","title":"Fields","text":"<p>When you use an expression as a layout by default the <code>field</code> layout will be used. This means that you will need to use this layout explicitly only if you want to provide some modifiers.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    field description: String\n    impl view form = grid {\n        x { code, name }\n        description &gt;&gt; field(span = 2)\n    }\n}\n</code></pre> <p><code>code</code> and <code>name</code> are also field here but we do not want to set any modifiers for those fields. But we want to set the <code>span</code> modifier to <code>2</code> for the <code>description</code> field so that it would span all two columns of our grid.</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#labels-and-headers","title":"Labels and Headers","text":"<p><code>label</code> is a static text that user cannot modify. You can also create a header using <code>h1</code>, <code>h2</code> or <code>h3</code>.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    field description: String\n    impl view form = y {\n        h2(\"Main fields\")\n        grid { code, name }\n        label(\"Some description about form\")\n    }\n}\n</code></pre> <p><code>label</code> seems to be deprecated and can no longer be used, just write a string inside the view</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#buttons","title":"Buttons","text":"<p>You can use <code>button</code>s to trigger some custom action when user press them.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    impl view form = y {\n        grid { code name }\n        button(\"Update name &amp; Code\") {\n            code = 1\n            name = \"Test\"\n        }\n    }\n}\n</code></pre> <p><code>button(\"Update name &amp; Code\")</code> created a button with title <code>\"Update name &amp; Code\"</code>. This is a shorter form of <code>button(label = \"Update name &amp; Code\")</code>. If you want to add some more modifiers you can simply write <code>button(\"Update name &amp; Code\", span = 2)</code>.</p> <p>Inside braces there is an action script which will be executed when user presses the button. In this example, we set code field to <code>1</code> and name to <code>\"Test\"</code>.</p> <p>Running back-end code with <code>button</code>s</p> <p>Sometimes you'd want to run a back-end job or trigger some back-end function on button press. You won't be able to do this normally with the code above, but if you wrap your back-end code in <code>!#dsl back { ... }</code> you'll be able to circumvent this. E.g.: <pre><code>...\nbutton(\"Run back-end job\") {\n    back {\n        SomeJob(...).enqueue()\n    }\n}\n...\n</code></pre></p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#styles","title":"Styles","text":"<p>This is literally never used, I'd be surprised if this even works</p> <p>There two ways how to set colors, fonts and other styles to your component: - CSS modifier - Style declaration and modifier</p> <p>Both ways will use CSS. You can use the CSS reference to find out what options are available.</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#css-modifier","title":"CSS modifier","text":"<p>Add CSS inline style to the component.</p> <pre><code>impl object view list = Company.all &gt;&gt; grid {\n    code\n    name &gt;&gt; field(css = \"background: red; color: white\")\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Layouts/#style-declaration-and-modifier","title":"Style declaration and modifier","text":"<p>Reference to style if you want to use a common style form few components.</p> <pre><code>entity Company {\n    field code: String\n    field name: String\n    object view list = Company.all &gt;&gt; grid {\n        code &gt;&gt; field(style = fieldStyle)\n        name &gt;&gt; field(style = fieldStyle)\n    }\n    style fieldStyle {\n        \"background: red;\n        color: white\"\n    }\n}\n</code></pre> <p>Here the <code>fieldStyle</code> style is declared. It is available also outside the entity by <code>Companies.fieldStyle</code> and can be declared in any place. For example there could be a <code>class Styles</code> which contains all styles. It is a good practice if you use the same styles in different entities. You can use selectors using <code>&amp;</code> literal to refer the style name.</p> <pre><code>style fieldStyle {\n    \"&amp; &gt; .field {\n        color: red;\n    }\"\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Layouts/#universal-modifiers","title":"Universal Modifiers","text":"<p>Some modifiers can be used for all layouts.</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#label","title":"<code>label</code>","text":"<p>Sets a label for layout which will be displayed in the header. By default, entity name will be used. It will be automatically translated into user-friendly string. For lists, singular form of entity name will be translated into plural. It does not work properly for all cases. So if plural for is incorrect, provide the <code>label</code> modifier.</p> <pre><code>object view list = Company.all &gt;&gt; nav {\n    table(label = \u201cCompanies\u201d) {code, name}\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Layouts/#visible","title":"<code>visible</code>","text":"<p>Dynamic visibility of layout components.</p> <pre><code>grid(visible = status == Bar) {\n    code\n    name\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Layouts/#css","title":"<code>css</code>","text":"<p>Add CSS inline style to the component.</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#style","title":"<code>style</code>","text":"<p>Reference to style if you want to use a common style form few components.</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#span","title":"<code>span</code>","text":"<p>Allows to expand the field on more than one column in parent layout. Default value is <code>1</code>.</p>"},{"location":"DSL-Dev-Guide/Views/Layouts/#editmode","title":"<code>editMode</code>","text":"<ul> <li><code>Inherit</code>: use the same mode as in parent view, default.</li> <li><code>AlwaysEdit</code>: element will be always in the edit mode.</li> <li><code>AlwaysRead</code>: element will be always read only.</li> <li><code>Inverse</code>: inverse the parent's mode so that it will be editable in the read mode and read only in edit mode.</li> </ul>"},{"location":"DSL-Dev-Guide/Views/Reports/","title":"Reports","text":"<p>Reports can show data by query. You have to provide a query for the report and you can provide a list view. List view can be auto-generated. The simplest report will look like this:</p> <pre><code>entity Invoice { \n    field number: String\n    field data: Date\n    field total: Dec[2]\n}\n\nreport InvoiceReport {\n    view list = Invoice.all\n}\n</code></pre> <p>Here the <code>Invoice</code> entity is declared for example. In <code>InvoiceReport</code> query is defined to select all invoices. You can declare a list view in the report the same way as with entity:</p> <pre><code>report InvoiceReport {\n    query = Invoice.all\n    view list = Invoice.all &gt;&gt; table{number, date, total}\n}\n</code></pre> <p>You can add the report to a menu:</p> <pre><code>menu ReportMenu {\n    report InvoiceReport\n}\n</code></pre> <p>You can make any complicated layout and inline queries there. For example, you can show results of multiple queries on the same screen:</p> <pre><code>report InvoiceReport {\n    view list = column {\n        Invoice.all\n        Order.all\n    }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Views/","title":"Views","text":""},{"location":"DSL-Dev-Guide/Views/Views/#list","title":"<code>list</code>","text":"<p>It determines how to display list of entity items.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    impl object view list = Company.all &gt;&gt; nav {\n        table { code, name }\n    }\n}\n</code></pre> <p>The <code>object</code> modifier means that this view does not have an instance of <code>Company</code> to display and should be started from a query. <code>Company.all</code> will select all companies. <code>nav</code> is a navigation layout and will create a navigation bar and filters panel. <code>table</code> will create a table with two columns <code>code</code> and <code>name</code>.</p>"},{"location":"DSL-Dev-Guide/Views/Views/#form","title":"<code>form</code>","text":"<p>A <code>form</code> view determines how one item will be shown to the user.</p> <pre><code>entity Company {\n    field code: Int\n    field name: String\n    impl view form = nav {\n        grid {\n            code\n            name\n        }\n    }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Views/#ref","title":"<code>ref</code>","text":"<p>A <code>ref</code> view allows to define how reference will look like in other entities. It can be useful if you want to display not only title but some additional information such as status.</p> <pre><code>entity Bug {\n    field title: String\n    ref field status: BugStatus\n    impl view ref = x { status title }\n}\n</code></pre> <p>After this all references to <code>Bug</code> will have status and title in a row.</p> <p>Warning</p> <p>If you are using a field in a <code>ref</code> view you should add a <code>ref</code> keyword to the view so that the data will be available for the reference view.</p>"},{"location":"DSL-Dev-Guide/Views/Views/#reflist","title":"<code>refList</code>","text":"<p>When you define a <code>ref</code> view it will be user for references list in the selector as well. However you can use a different view if you want. For example if you want to use a table selector list:</p> <pre><code>entity Product {\n    field code: String\n    field title: String\n    impl view ref = y { title code }\n    impl object view refList = Product.all &gt;&gt; table { title code }\n}\n</code></pre>"},{"location":"DSL-Dev-Guide/Views/Views/#traititem","title":"<code>traitItem</code>","text":"<p>This view will be used for a trait list to display a particular item.</p> <p><pre><code>trait Issue {\n    field title: String\n}\n\nentity Bug extends Issue {\n    field severity: Severity\n    view traitItem = grid { title severity }\n}\n\nentity UserStory extends Issue {\n    field feature: Feature\n    view traitItem = grid { title feature }\n}\n</code></pre> One <code>traitItem</code> view will be used to represent <code>Bug</code> entities and another for <code>UserStory</code> entities.</p>"},{"location":"DSL-Linker/","title":"DSL Linker Documentation","text":""},{"location":"DSL-Linker/#overview","title":"Overview","text":"<p>The DSL Linker is a crucial component of the ERP system that handles the linking and resolution of DSL (Domain Specific Language) code. It's responsible for:</p> <ul> <li>Resolving type references</li> <li>Linking declarations</li> <li>Handling class inheritance and extensions</li> <li>Managing environment availability (Back/Front)</li> <li>Processing properties and expressions</li> </ul>"},{"location":"DSL-Linker/#core-components","title":"Core Components","text":""},{"location":"DSL-Linker/#1-dsllinker","title":"1. DslLinker","text":"<p>The main entry point for the linking process. Key responsibilities:</p> <ul> <li>Linking AST (Abstract Syntax Tree) with dependencies</li> <li>Managing class resolution</li> <li>Handling type linking</li> <li>Processing declarations</li> </ul> <pre><code>object DslLinker {\n  def apply(ast: LinkAst, deps: List[Dependency])(implicit idGen: DslIdGen): Checked[LinkAst]\n  def linkExpr(envAvailability: EnvAvailability, expr: Expr, deps: List[Dependency])(implicit idGen: DslIdGen): Checked[Expr]\n  def linkGeneratorCall(envAvailability: EnvAvailability, expr: Expr, deps: List[Dependency], selfId: DslId)(implicit idGen: DslIdGen): Checked[Expr]\n}\n</code></pre>"},{"location":"DSL-Linker/#2-linkast","title":"2. LinkAst","text":"<p>Represents the linked AST structure:</p> <ul> <li>Contains application components and statements</li> <li>Handles class uniqueness checks</li> <li>Manages environment availability</li> <li>Provides finalization of statements</li> </ul> <pre><code>case class LinkAst(appComps: List[AppVersionComp], stms: Array[Statement])\n</code></pre>"},{"location":"DSL-Linker/#3-typelink","title":"3. TypeLink","text":"<p>Handles type resolution and linking:</p> <ul> <li>Manages type resolution steps</li> <li>Handles properties linking</li> <li>Processes class extensions</li> <li>Maintains type hierarchy</li> </ul> <pre><code>object TypeLink {\n  def apply(complete: DslType): TypeLink\n  def apply(linker: DslLinker, origin: DslType, parentId: Option[DslId], relink: Boolean): TypeLink\n}\n</code></pre>"},{"location":"DSL-Linker/#4-decllink","title":"4. DeclLink","text":"<p>Manages declaration linking:</p> <ul> <li>Handles declaration resolution</li> <li>Processes property linking</li> <li>Manages virtual mapping</li> <li>Handles extension declarations</li> </ul> <pre><code>object DeclLink {\n  def apply(complete: Decl): DeclLink\n  def apply(linker: DslLinker, origin: Decl, dslType: TypeLink, relink: Boolean): DeclLink\n}\n</code></pre>"},{"location":"DSL-Linker/#key-concepts","title":"Key Concepts","text":""},{"location":"DSL-Linker/#environment-availability","title":"Environment Availability","text":"<p>The DSL supports different environments:</p> <ul> <li><code>Back</code>: Backend-only code</li> <li><code>Front</code>: Frontend-only code</li> <li><code>BackFront</code>: Code available in both environments</li> </ul>"},{"location":"DSL-Linker/#class-resolution","title":"Class Resolution","text":"<p>Classes are resolved through the <code>ClassResolver</code> which:</p> <ul> <li>Maintains a hierarchy of classes</li> <li>Handles package resolution</li> <li>Manages type references</li> <li>Supports generic types</li> </ul>"},{"location":"DSL-Linker/#type-system","title":"Type System","text":"<p>The type system includes:</p> <ul> <li>Basic types (classes, traits)</li> <li>Generic types</li> <li>Optional types</li> <li>Tuple types</li> <li>Query types</li> </ul>"},{"location":"DSL-Linker/#declaration-resolution","title":"Declaration Resolution","text":"<p>Declarations are resolved through:</p> <ul> <li>Self-type resolution</li> <li>Superclass traversal</li> <li>Property linking</li> <li>Extension handling</li> </ul>"},{"location":"DSL-Linker/#common-use-cases","title":"Common Use Cases","text":""},{"location":"DSL-Linker/#1-linking-a-dsl-expression","title":"1. Linking a DSL Expression","text":"<pre><code>val result = DslLinker.linkExpr(\n  envAvailability = EnvAvailability.BackFront,\n  expr = someExpression,\n  deps = dependencies\n)\n</code></pre>"},{"location":"DSL-Linker/#2-resolving-a-type-reference","title":"2. Resolving a Type Reference","text":"<pre><code>val typeLink = classResolver.resolveWithFullName(\"core.SomeType\")\n</code></pre>"},{"location":"DSL-Linker/#3-processing-properties","title":"3. Processing Properties","text":"<pre><code>val props = DslProps(exprs).link(propertiesType)\n</code></pre>"},{"location":"DSL-Linker/#error-handling","title":"Error Handling","text":"<p>The linker provides comprehensive error handling through:</p> <ul> <li><code>DslLinkException</code>: Base class for linking errors</li> <li><code>DslClassNotFound</code>: When a referenced class cannot be found</li> <li><code>DeclNotFound</code>: When a declaration cannot be resolved</li> <li><code>SuitableDeclNotFound</code>: When no matching declaration is found</li> <li><code>ExtensionNotFound</code>: When an extension cannot be found</li> </ul>"},{"location":"DSL-Linker/#best-practices","title":"Best Practices","text":"<ol> <li>Always specify environment availability when linking expressions</li> <li>Handle dependencies in the correct order</li> <li>Use proper type resolution through ClassResolver</li> <li>Implement proper error handling for linking failures</li> <li>Follow the linking steps in the correct order (types \u2192 declarations \u2192 properties)</li> </ol>"},{"location":"DSL-Linker/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Not handling environment availability correctly</li> <li>Missing dependencies in the linking process</li> <li>Incorrect type resolution order</li> <li>Not properly handling extensions</li> <li>Missing error handling for linking failures</li> </ol>"},{"location":"DSL-Linker/#next-steps","title":"Next Steps","text":"<p>For more advanced topics, consider exploring:</p> <ol> <li>Generator types and their resolution</li> <li>Complex type inference</li> <li>Advanced property linking</li> <li>Custom type extensions</li> <li>Performance optimization techniques</li> </ol>"},{"location":"DSL-Linker/1/","title":"TypeLink and StepLink Components","text":""},{"location":"DSL-Linker/1/#overview","title":"Overview","text":"<p>The TypeLink and StepLink components form the core of the DSL linker's type resolution system. They implement a lazy evaluation mechanism that allows for efficient and safe type resolution in the DSL.</p>"},{"location":"DSL-Linker/1/#steplink-the-base-component","title":"StepLink - The Base Component","text":"<p><code>StepLink</code> is a generic base class that implements lazy evaluation of a value through a series of steps. It's the foundation for all linking operations in the DSL.</p>"},{"location":"DSL-Linker/1/#core-implementation","title":"Core Implementation","text":"<pre><code>class StepLink[T](origin: T, steps: List[Step[T]]) {\n  private var _number = -1\n  private var _steps = steps\n  private var _value: T = origin\n  private var calculating = false\n\n  def any: T = _value\n  def after(step: StepId[T]): T = {\n    while ((_steps ne Nil) &amp;&amp; step.number &gt; _number)\n      calcNext()\n    _value\n  }\n  def complete: T = {\n    while (_steps.nonEmpty)\n      calcNext()\n    _value\n  }\n}\n</code></pre>"},{"location":"DSL-Linker/1/#key-concepts","title":"Key Concepts","text":"<ol> <li>Lazy Evaluation</li> <li>Values are only computed when needed through <code>after</code> or <code>complete</code> methods</li> <li>Prevents unnecessary computations and helps with performance</li> <li> <p>Enables handling of circular dependencies</p> </li> <li> <p>Step-based Processing</p> </li> <li>Each step transforms the value in some way</li> <li>Steps are executed in order based on their number</li> <li> <p>Allows for complex transformations to be broken down into manageable pieces</p> </li> <li> <p>Recursion Protection</p> </li> <li>The <code>calculating</code> flag prevents recursive calculations</li> <li>Throws <code>LazyRecursiveCalculation</code> if recursion is detected</li> <li> <p>Ensures type resolution terminates</p> </li> <li> <p>Runtime Status Integration</p> </li> <li>Uses <code>RuntimeStatus.checkExiting()</code> to handle graceful shutdown</li> <li>Prevents hanging during type resolution</li> <li>Ensures clean application termination</li> </ol>"},{"location":"DSL-Linker/1/#typelink-type-resolution-component","title":"TypeLink - Type Resolution Component","text":"<p><code>TypeLink</code> extends <code>StepLink[DslType]</code> and adds type-specific functionality for DSL type resolution.</p>"},{"location":"DSL-Linker/1/#core-implementation_1","title":"Core Implementation","text":"<pre><code>final class TypeLink(origin: DslType, steps: List[Step[DslType]]) \n    extends StepLink[DslType](origin, steps) {\n\n  // Type-specific properties\n  def dslId: DslId = any.dslId\n  def fullName: DslFullName = any.fullName\n  def isExtension: Boolean = any.isExtension\n  def isInner: Boolean = any.isInner\n  def isTypeAbstract: Boolean = any.isTypeAbstract\n\n  // Resolution methods\n  def resolved: DslType = after(ResolveStep)\n  def resolved0: DslType = after(ResolveStep0)\n  def propsResolved: DslType = after(PropsStep)\n}\n</code></pre>"},{"location":"DSL-Linker/1/#resolution-steps","title":"Resolution Steps","text":"<p>The TypeLink component defines three main resolution steps:</p> <pre><code>case object ResolveStep0 extends StepId[DslType](0)\ncase object ResolveStep extends StepId[DslType](1)\ncase object PropsStep extends StepId[DslType](2)\n</code></pre> <p>Each step serves a specific purpose:</p> <ol> <li>ResolveStep0</li> <li>Initial type resolution</li> <li>Used for special cases like Role types</li> <li> <p>Performs basic type validation</p> </li> <li> <p>ResolveStep</p> </li> <li>Full type resolution</li> <li>Handles type parameters and generics</li> <li> <p>Resolves superclass relationships</p> </li> <li> <p>PropsStep</p> </li> <li>Property resolution</li> <li>Processes type properties</li> <li>Handles property inheritance</li> </ol>"},{"location":"DSL-Linker/1/#factory-methods","title":"Factory Methods","text":"<p>TypeLink provides several factory methods for creating instances:</p> <pre><code>object TypeLink {\n  // Create from a complete DslType\n  def apply(complete: DslType): TypeLink = \n    new TypeLink(complete, steps = Nil)\n\n  // Create from a DeclLink (lazy resolution)\n  def apply(lazyComplete: DeclLink): TypeLink = \n    new TypeLink(\n      lazyComplete.any.asInstanceOf[DslType],\n      steps = List(new Step(ResolveStep, \n        _ =&gt; lazyComplete.complete.asInstanceOf[DslType]))\n    )\n}\n</code></pre>"},{"location":"DSL-Linker/1/#complex-resolution-process","title":"Complex Resolution Process","text":"<p>The main resolution process is handled by a complex factory method:</p> <pre><code>def apply(linker: DslLinker, origin: DslType, parentId: Option[DslId], relink: Boolean): TypeLink = {\n  var r: List[Step[DslType]] = Nil\n\n  // Add property resolution step if needed\n  if (origin.isInstanceOf[DeclWithProps]) {\n    r = new Step(PropsStep, ...) :: r\n  }\n\n  // Add special handling for Role types\n  val isRoles = origin.fullName.toString == \"core.Role$\"\n  if (isRoles) {\n    r = new Step(ResolveStep, ...) :: r\n  }\n\n  // Add main resolution step\n  r = new Step(if (isRoles) ResolveStep0 else ResolveStep, ...) :: r\n\n  new TypeLink(origin, r)\n}\n</code></pre>"},{"location":"DSL-Linker/1/#common-use-cases","title":"Common Use Cases","text":""},{"location":"DSL-Linker/1/#1-basic-type-resolution","title":"1. Basic Type Resolution","text":"<pre><code>val typeLink = TypeLink(someDslType)\nval resolvedType = typeLink.resolved\n</code></pre>"},{"location":"DSL-Linker/1/#2-property-resolution","title":"2. Property Resolution","text":"<pre><code>val typeWithProps = typeLink.propsResolved\n</code></pre>"},{"location":"DSL-Linker/1/#3-generic-type-handling","title":"3. Generic Type Handling","text":"<pre><code>def generic(dslType: DslTypeGeneric, i: Int, ctx: =&gt; LinkContext): TypeLink =\n  new TypeLink(dslType, new Step(ResolveStep, \n    (c: DslType) =&gt; c.asInstanceOf[DslTypeGeneric].link(i)(ctx)) :: Nil)\n</code></pre>"},{"location":"DSL-Linker/1/#important-notes","title":"Important Notes","text":"<ol> <li>Lazy Evaluation</li> <li>Type resolution is performed only when needed</li> <li>Improves performance by avoiding unnecessary computations</li> <li> <p>Helps prevent circular dependencies</p> </li> <li> <p>Step Ordering</p> </li> <li>Steps are executed in order based on their number</li> <li>Ensures consistent resolution process</li> <li> <p>Allows for complex transformations</p> </li> <li> <p>Type Safety</p> </li> <li>Maintains type safety through generic parameter T</li> <li>Prevents type-related errors at compile time</li> <li> <p>Ensures correct type resolution</p> </li> <li> <p>Error Handling</p> </li> <li>Recursive calculations are caught and handled gracefully</li> <li>Provides clear error messages for debugging</li> <li>Prevents infinite loops in type resolution</li> </ol>"},{"location":"DSL-Linker/1/#best-practices","title":"Best Practices","text":"<ol> <li>Always use the appropriate resolution method for your needs</li> <li>Be aware of the lazy evaluation nature of the component</li> <li>Handle potential recursive calculations</li> <li>Use the factory methods instead of direct construction</li> <li>Consider the order of resolution steps when adding new ones</li> </ol>"},{"location":"DSL-Linker/1/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Not handling recursive calculations properly</li> <li>Forgetting to check runtime status</li> <li>Using wrong resolution step for the task</li> <li>Not considering lazy evaluation implications</li> <li>Ignoring type safety constraints </li> </ol>"},{"location":"DSL-Linker/2/","title":"Location (Loc) Component","text":""},{"location":"DSL-Linker/2/#overview","title":"Overview","text":"<p>The <code>Loc</code> component is responsible for tracking source code locations in the DSL. It provides a unified way to represent and compare source code positions, which is essential for error reporting and debugging.</p>"},{"location":"DSL-Linker/2/#core-components","title":"Core Components","text":""},{"location":"DSL-Linker/2/#location-types","title":"Location Types","text":"<p>The <code>Loc</code> trait defines three main implementations:</p> <ol> <li>KnownLoc - Represents a specific location in source code</li> <li>UnknownLoc - Represents an unknown location</li> <li>NoLoc - Represents a non-existent location (used for synthetic nodes)</li> </ol>"},{"location":"DSL-Linker/2/#core-implementation","title":"Core Implementation","text":"<pre><code>sealed trait Loc extends Ordered[Loc] {\n  def location: String\n  def near: String\n  def file: String\n}\n</code></pre>"},{"location":"DSL-Linker/2/#location-types-in-detail","title":"Location Types in Detail","text":""},{"location":"DSL-Linker/2/#knownloc","title":"KnownLoc","text":"<p>Represents a specific location in source code with file, line, and column information:</p> <pre><code>final class KnownLoc(\n  val file: String, \n  val line: Int, \n  val column: Int, \n  val unformattedNear: String\n) extends Loc {\n  def location = s\"$file:$line:$column\"\n  override def near: String = unformattedNear.trim\n}\n</code></pre> <p>Key features:</p> <ul> <li>Tracks exact file, line, and column information</li> <li>Provides formatted location string</li> <li>Includes source code context (\"near\" text)</li> <li>Implements proper comparison and equality</li> </ul>"},{"location":"DSL-Linker/2/#unknownloc","title":"UnknownLoc","text":"<p>Represents a location that cannot be determined:</p> <pre><code>case object UnknownLoc extends Loc {\n  override def file: String = \"\"\n  override def location: String = \"Unknown\"\n  override def near: String = \"Unknown\"\n}\n</code></pre> <p>Key features:</p> <ul> <li>Used when source location cannot be determined</li> <li>Implements special equality rules</li> <li>Provides fallback location information</li> </ul>"},{"location":"DSL-Linker/2/#noloc","title":"NoLoc","text":"<p>Represents a synthetic or non-existent location:</p> <pre><code>case object NoLoc extends Loc {\n  override def file: String = \"\"\n  override def location: String = \"Nothing\"\n  override def near: String = \"Nothing\"\n}\n</code></pre> <p>Key features:</p> <ul> <li>Used for synthetic nodes or generated code</li> <li>Implements special equality rules</li> <li>Provides minimal location information</li> </ul>"},{"location":"DSL-Linker/2/#factory-methods","title":"Factory Methods","text":"<p>The <code>Loc</code> object provides factory methods for creating locations:</p> <pre><code>object Loc {\n  def apply(file: String, position: Position, fullNear: Boolean): Loc = \n    position match {\n      case o: OffsetPosition =&gt;\n        new KnownLoc(\n          file,\n          position.line,\n          if (position.line &gt; 0) position.column else 0,\n          if (fullNear) o.source.toString else if (position.line &gt; 0) o.lineContents else \"\"\n        )\n      case _ =&gt; UnknownLoc\n    }\n\n  def apply(file: String, line: Int, column: Int, near: String) = \n    new KnownLoc(file, line, column, near)\n}\n</code></pre>"},{"location":"DSL-Linker/2/#location-comparison","title":"Location Comparison","text":"<p>The <code>Loc</code> trait implements <code>Ordered[Loc]</code> to provide consistent ordering:</p> <pre><code>override def compare(that: Loc): Int =\n  if ((that eq UnknownLoc) || (that eq NoLoc)) -1\n  else {\n    val t = that.asInstanceOf[KnownLoc]\n    val i0 = file.compare(t.file)\n    if (i0 == 0) {\n      val i1 = line.compare(t.line)\n      if (i1 == 0) column.compare(t.column)\n      else i1\n    } else i0\n  }\n</code></pre> <p>Ordering rules:</p> <ol> <li>UnknownLoc and NoLoc are considered equal</li> <li>KnownLoc instances are ordered by:<ul> <li>File name</li> <li>Line number</li> <li>Column number</li> </ul> </li> </ol>"},{"location":"DSL-Linker/2/#common-use-cases","title":"Common Use Cases","text":""},{"location":"DSL-Linker/2/#1-creating-a-location-from-parser-position","title":"1. Creating a Location from Parser Position","text":"<pre><code>val loc = Loc(\"MyFile.scala\", parserPosition, fullNear = true)\n</code></pre>"},{"location":"DSL-Linker/2/#2-creating-a-location-with-specific-coordinates","title":"2. Creating a Location with Specific Coordinates","text":"<pre><code>val loc = Loc(\"MyFile.scala\", line = 42, column = 10, near = \"def example()\")\n</code></pre>"},{"location":"DSL-Linker/2/#3-error-reporting","title":"3. Error Reporting","text":"<pre><code>def reportError(loc: Loc, message: String): Unit = {\n  println(s\"${loc.location}: $message\")\n  println(s\"Near: ${loc.near}\")\n}\n</code></pre>"},{"location":"DSL-Linker/2/#important-notes","title":"Important Notes","text":"<ol> <li> <p>Location Equality</p> <ul> <li>UnknownLoc equals any other location</li> <li>NoLoc equals UnknownLoc or NoLoc</li> <li>KnownLoc instances are equal if they have the same file, line, and column</li> </ul> </li> <li> <p>Source Context</p> <ul> <li>The \"near\" text provides context around the location</li> <li>Can be full source or just the line contents</li> <li>Useful for error messages and debugging</li> </ul> </li> <li> <p>Location Ordering</p> <ul> <li>Provides consistent ordering for error reporting</li> <li>Helps in organizing and displaying multiple errors</li> <li>Maintains natural source code order</li> </ul> </li> </ol>"},{"location":"DSL-Linker/2/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide location information when possible</li> <li>Use appropriate location type for the context</li> <li>Include meaningful \"near\" text for better error messages</li> <li>Handle unknown locations gracefully</li> <li>Consider location ordering in error reporting</li> </ol>"},{"location":"DSL-Linker/2/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Not providing enough context in \"near\" text</li> <li>Ignoring location information in error handling</li> <li>Incorrect handling of UnknownLoc and NoLoc</li> <li>Not considering location ordering in error reports</li> <li>Missing file information in location objects </li> </ol>"},{"location":"DSL-Linker/3/","title":"Decl and TextGen Components","text":""},{"location":"DSL-Linker/3/#overview","title":"Overview","text":"<p>The <code>Decl</code> and <code>TextGen</code> components are fundamental parts of the DSL system, responsible for representing declarations and generating text representations of DSL elements.</p>"},{"location":"DSL-Linker/3/#decl-component","title":"Decl Component","text":""},{"location":"DSL-Linker/3/#core-concepts","title":"Core Concepts","text":"<p>The <code>Decl</code> trait represents a declaration in the DSL system. It provides a unified way to represent various types of declarations like fields, functions, and types.</p>"},{"location":"DSL-Linker/3/#key-properties","title":"Key Properties","text":"<ol> <li> <p>Basic Properties</p> <ul> <li><code>dslId</code>: Unique identifier for the declaration</li> <li><code>name</code>: Name of the declaration</li> <li><code>tp</code>: Type of the declaration</li> <li><code>at</code>: Source code location</li> <li><code>params</code>: List of parameters</li> <li><code>declGenerics</code>: Generic type parameters</li> <li><code>value</code>: Expression value</li> <li><code>props</code>: Properties associated with the declaration</li> </ul> </li> <li> <p>Modifiers</p> <ul> <li><code>isConst</code>: Whether the declaration is constant</li> <li><code>isReadOnly</code>: Whether the declaration is read-only</li> <li><code>isObjectDecl</code>: Whether it's an object declaration</li> <li><code>isReference</code>: Whether it's a reference declaration</li> <li><code>allowFutureEscape</code>: Whether it allows future escape</li> </ul> </li> </ol>"},{"location":"DSL-Linker/3/#declaration-types","title":"Declaration Types","text":"<ol> <li> <p>DeclInst</p> <ul> <li>Base trait for instance declarations</li> <li>Provides implementation details</li> <li>Handles visibility and environment availability</li> </ul> </li> <li> <p>DeclParam</p> <ul> <li>Represents function parameters</li> <li>Includes name, type, and default value</li> </ul> </li> <li> <p>DeclFunc</p> <ul> <li>Represents function declarations</li> <li>Handles virtual method dispatch</li> <li>Supports event handling</li> </ul> </li> <li> <p>DeclField</p> <ul> <li>Represents field declarations</li> <li>Supports stored and computed fields</li> <li>Handles field properties</li> </ul> </li> </ol>"},{"location":"DSL-Linker/3/#common-use-cases","title":"Common Use Cases","text":"<ol> <li> <p>Creating a Field Declaration <pre><code>val field = DeclFieldStored(\n  dslId = idGen.next,\n  at = location,\n  mods = DeclModsField.default,\n  fullName = DslFullName.basic(\"myField\"),\n  tp = TpString.basic,\n  value = Nop,\n  props = DslProps.empty\n)\n</code></pre></p> </li> <li> <p>Creating a Function Declaration <pre><code>val func = DeclFunc(\n  dslId = idGen.next,\n  at = location,\n  mods = DeclModsFunc.default,\n  fullName = DslFullName.basic(\"myFunction\"),\n  declGenerics = DeclGenerics.empty,\n  params = List(param1, param2),\n  tp = returnType,\n  value = functionBody,\n  props = DslProps.empty\n)\n</code></pre></p> </li> </ol>"},{"location":"DSL-Linker/3/#textgen-component","title":"TextGen Component","text":""},{"location":"DSL-Linker/3/#core-concepts_1","title":"Core Concepts","text":"<p>The <code>TextGen</code> trait provides a mechanism for generating text representations of DSL elements. It's used for pretty-printing, debugging, and serialization.</p>"},{"location":"DSL-Linker/3/#key-features","title":"Key Features","text":"<ol> <li> <p>Text Generation</p> <ul> <li><code>textGen</code>: Core method for generating text</li> <li><code>toString</code>: Default implementation using textGen</li> <li><code>tgInd</code>: Indentation control</li> <li><code>tgNewLine</code>: Line break control</li> <li><code>tgSeq</code>: Sequence generation with separators</li> </ul> </li> <li> <p>String Interpolation <pre><code>implicit def toTextGenInterpolator(sc: StringContext)(implicit buf: TextGenBuffer): TextGenInterpolator\n</code></pre>     Provides string interpolation support with <code>tg\"...\"</code> syntax</p> </li> <li> <p>Buffer Management</p> <ul> <li>Indentation control</li> <li>Line break handling</li> <li>String building</li> </ul> </li> </ol>"},{"location":"DSL-Linker/3/#common-use-cases_1","title":"Common Use Cases","text":"<ol> <li> <p>Generating Text for a Type <pre><code>override def textGen(implicit buf: TextGenBuffer): Unit = {\n  tg\"$name\"\n  if (generics.nonEmpty) {\n    tg\"[${generics.mkString(\", \")}]\"\n  }\n}\n</code></pre></p> </li> <li> <p>Generating Text for a Function <pre><code>override def textGen(implicit buf: TextGenBuffer): Unit = {\n  mods.textGen\n  tg\"func $name\"\n  if (params.nonEmpty) {\n    tg\"(${params.mkString(\", \")})\"\n  }\n  if (tp != TpVoid) {\n    tg\": $tp\"\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"DSL-Linker/3/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Declaration Creation</p> <ul> <li>Always provide unique DSL IDs</li> <li>Include proper source locations</li> <li>Set appropriate modifiers</li> <li>Handle generic parameters correctly</li> </ul> </li> <li> <p>Text Generation</p> <ul> <li>Use proper indentation</li> <li>Include meaningful separators</li> <li>Handle special cases gracefully</li> <li>Maintain consistent formatting</li> </ul> </li> </ol>"},{"location":"DSL-Linker/3/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li> <p>Declaration Issues</p> <ul> <li>Missing required properties</li> <li>Incorrect type handling</li> <li>Improper generic parameter usage</li> <li>Missing source locations</li> </ul> </li> <li> <p>Text Generation Issues</p> <ul> <li>Inconsistent indentation</li> <li>Missing separators</li> <li>Improper line breaks</li> <li>Unclear formatting </li> </ul> </li> </ol>"},{"location":"System-Maintenance/Deployments/","title":"Deployments","text":"<p>As it stands the CI/CD pipeline is using GitHub Actions under the hood. Builds themselves are also done during those actions, so you can find all the details in the platform repo under the corresponding instance branch <code>deploy/&lt;instance name&gt;</code>. The script at the end of those deployments should just copy the resulting builds and properly move the files into their respective folders, while removing unecessary / backuping necessary files &amp; restarting docker containers.</p> <p>Sometimes docker restarts mess with IP and the routing breaks, TODO fix this</p>"},{"location":"System-Maintenance/Deployments/#front-end","title":"Front-end","text":"<p>There's a simple webpack configuration for building production-ready front-end. There are a few quirks or missing parts though:</p> <ol> <li>As it stands I can't dynamically load page title (used to differentiate between instances) from configuration inside webpack config, the auto-generated <code>index.html</code> will always come with default title that you'll need to adjust manually (only once, the index.html won't get overriden for most deployments).</li> <li>It's aleady been added to the deployment actions &amp; scripts, but still pay close attention to how <code>public</code> folder is created and be sure to move over all your custom config files in there (they won't be touched by automatic deployment tools) if you want public functionality to work within our platform.</li> <li>As stated previously config values can't be realistically pre-filled for deployments so you'll have to fill those yourself (currently there are two configs: one generic and one for firebase). The placeholders should be copied over with <code>PLACEHOLDER_</code> prefix in the filename, it should give you an idea on what fields are required.</li> </ol> <p>Correct asset loading is WIP, the routing appears to be somewhat broken or inconsistent, for fonts and other assets especially</p>"},{"location":"System-Maintenance/Deployments/#back-end","title":"Back-end","text":"<p>There's a bundler plugin for sbt that produces full builds of our backend without much issues. Some notes:</p> <ol> <li>As with the front-end you'll have to manually supply correct configuration files, unfortunately there are no placeholder files generated by the build process for now so you'll have to copy and adapt previous instances config files / check platform repo for those. Most important are <code>flow2b.conf</code> and <code>application.conf</code>. You'll probably also need to copy orientdb configuration files assuming you're moving existing DB over there and not starting from clean slate.</li> <li>Back-end requires a lot of ENV variables and JAVA args to be present in order to function at all (also lots of optimizations are done there). No templates for that yet as well, you can look into <code>build.sbt</code> of the platform to check which env variables are defined there but your best bet would be to copy over the run script and args files from existing instances.</li> </ol>"},{"location":"System-Maintenance/File-Upload/","title":"File Upload","text":""},{"location":"System-Maintenance/File-Upload/#limits","title":"Limits","text":"<p>Our platform imposes limits on incoming &amp; uploaded files in different ways.</p>"},{"location":"System-Maintenance/File-Upload/#front-end","title":"Front-end","text":"<p>There's a size limit on file drop-down component that can be adjusted by modifying <code>maxUploadedFileSize</code> value (number in MB) in the JS config (usually in the root of deployed front-end in <code>config.js</code>).</p>"},{"location":"System-Maintenance/File-Upload/#back-end","title":"Back-end","text":"<p>There are two config values seemingly responsible for handling file size limits on back-end imposed by Akka:</p> <ol> <li><code>akka.http.server.parsing.max-content-length</code>.</li> <li><code>akka.http.routing.decode-max-size</code>.</li> </ol> <p>It's best to update both of those to the same value. Those values are likely present in the <code>conf/application.conf</code> file in your back-end deployment.</p>"},{"location":"System-Maintenance/File-Upload/#other-infrastructure","title":"Other infrastructure","text":"<p>Postal mail server and our routing infrastructure may also impose additional limits on file sizes.</p> <p>TODO: document infra part in more detail</p>"}]}